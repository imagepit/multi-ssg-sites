#!/usr/bin/env zsh

# ログ設定（絶対パスで設定）
REPO_ROOT=$(git rev-parse --show-toplevel)
LOG_FILE="$REPO_ROOT/.git/hooks/post-commit.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

log_message() {
    echo "[$TIMESTAMP] $1" | tee -a "$LOG_FILE"
}

# Slack通知関数
send_slack_notification() {
    local site_id="$1"
    local files_list="$2"
    local webhook_url="https://hooks.slack.com/services/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"
    
    log_message "Preparing Slack notification for site: $site_id"
    
    # メッセージの構築
    local message="コンテンツが更新されアップロードされました。\n\n## 対象URL\n"
    
    # 各ファイルのURLを生成
    for relative_file in ${=files_list}; do
        # .mdを除いたファイル名を取得
        local url_path="${relative_file%.md}"
        local full_url="https://${site_id}.dx-wp.net/${url_path}"
        message="${message}${full_url}\n"
        log_message "Added URL to notification: $full_url"
    done
    
    # JSONペイロードを作成
    local json_payload=$(cat <<EOF
{
    "text": "$message"
}
EOF
)
    
    log_message "Sending Slack notification..."
    log_message "Payload: $json_payload"
    
    # curlでSlackに送信
    if curl -X POST -H 'Content-type: application/json' \
        --data "$json_payload" \
        "$webhook_url" >> "$LOG_FILE" 2>&1; then
        log_message "Slack notification sent successfully"
        return 0
    else
        log_message "Failed to send Slack notification"
        return 1
    fi
}

# Zshバージョンを確認
log_message "Zsh version: $ZSH_VERSION"

# コミットで変更されたファイルを取得（配列として取得）
changed_files=(${(f)"$(git diff-tree --no-commit-id --name-only -r HEAD)"})

# サイトごとに処理したファイルを記録（zshの連想配列）
typeset -A site_files
log_message "Declared associative array site_files"

# 連想配列のテスト
site_files[test]="value"
log_message "Test: site_files[test] = ${site_files[test]}"
log_message "Test: array keys = ${(k)site_files}"
unset "site_files[test]"

log_message "Starting post-commit hook"
log_message "Changed files count: ${#changed_files[@]}"
log_message "Changed files: ${changed_files[@]}"

# ファイルをサイトIDごとにグループ化
for file in "${changed_files[@]}"; do
    log_message "Processing file: $file"
    if [[ -f "$file" && "$file" =~ ^docs/([^/]+)/contents/(.*)\.md$ ]]; then
        # zshでは match 配列を使用
        log_message "Match array contents: ${match[@]}"
        site_id="${match[1]}"
        relative_path="${match[2]}.md"
        
        log_message "Matched site_id: '$site_id', relative_path: '$relative_path'"
        
        # サイトIDが空でないことを確認
        if [[ -z "$site_id" ]]; then
            log_message "Warning: Empty site_id for file $file, skipping"
            continue
        fi
        
        # サイトディレクトリの存在確認
        site_dir="docs/$site_id"
        if [[ ! -d "$site_dir" ]]; then
            log_message "Warning: Site directory $site_dir not found, skipping $file"
            continue
        fi
        
        # .envファイルの存在確認
        if [[ ! -f "$site_dir/.env" ]]; then
            log_message "Warning: .env file not found in $site_dir, skipping $file"
            continue
        fi
        
        # サイトファイルリストに追加
        log_message "Before adding: site_id='$site_id', relative_path='$relative_path'"
        
        if [[ -z "${site_files[$site_id]}" ]]; then
            site_files[$site_id]="$relative_path"
            log_message "Set site_files[$site_id] = $relative_path"
        else
            # 複数ファイルの場合はスペース区切りで追加
            site_files[$site_id]="${site_files[$site_id]} $relative_path"
            log_message "Appended to site_files[$site_id]: now contains '${site_files[$site_id]}'"
        fi
        
        log_message "After adding: site_files[$site_id] = ${site_files[$site_id]}"
        
        # デバッグ: 現在の連想配列の状態を確認（zsh形式）
        log_message "Current array keys: ${(k)site_files}"
        
        log_message "Queued for processing: $file (Site: $site_id)"
    fi
done

# デバッグ: 連想配列の内容を確認
log_message "Site files array contents:"
for key in ${(k)site_files}; do
    log_message "  Key: '$key', Value: '${site_files[$key]}'"
done

# サイトごとに処理実行
for site_id in ${(k)site_files}; do
    log_message "Iterating over site_id: '$site_id'"
    site_dir="docs/$site_id"
    files_list="${site_files[$site_id]}"
    
    log_message "Processing site: '$site_id'"
    log_message "Site directory: '$site_dir'"
    log_message "Files to process: '$files_list'"
    
    (
        # サブシェル内で必要な変数を再定義
        REPO_ROOT=$(git rev-parse --show-toplevel)
        LOG_FILE="$REPO_ROOT/.git/hooks/post-commit.log"
        TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        
        # サブシェル内でもログ関数を使えるようにする
        log_message() {
            echo "[$TIMESTAMP] $1" | tee -a "$LOG_FILE"
        }
        
        # エラートラップを設定
        trap 'log_message "Error at line $LINENO in subshell"' ERR
        
        log_message "Entering subshell for site: $site_id"
        
        cd "$REPO_ROOT/$site_dir" || {
            log_message "Error: Failed to change directory to $REPO_ROOT/$site_dir"
            log_message "Current directory: $(pwd)"
            log_message "Directory exists: $(ls -la $REPO_ROOT/docs/ | grep $site_id || echo 'Not found')"
            exit 1
        }
        
        log_message "Successfully changed directory to: $(pwd)"
        
        # .envファイルの読み込み（必要に応じて）
        if [[ -f ".env" ]]; then
            log_message "Loading .env file from $site_dir"
            # 必要に応じて環境変数をexport
            set -a; source .env; set +a
        fi
        
        # 各ファイルに対してコマンド実行（スペース区切りの文字列を配列として処理）
        for relative_file in ${=files_list}; do
            file_path="./contents/$relative_file"
            
            if [[ -f "$file_path" ]]; then
                log_message "Executing: wp-post -f $file_path"
                
                if wp-post -f "$file_path" >> "$LOG_FILE" 2>&1; then
                    log_message "Successfully processed: $file_path"
                else
                    log_message "Error processing: $file_path"
                    exit 1
                fi
            else
                log_message "Warning: File not found: $file_path"
            fi
        done
        
        log_message "Completed processing for site: $site_id"
        exit 0
    )
    
    local exit_status=$?
    log_message "Subshell exit status: $exit_status"
    
    if [ $exit_status -ne 0 ]; then
        log_message "Error occurred while processing site: $site_id (exit status: $exit_status)"
        exit 1
    else
        # wp-post処理が成功した場合、Slack通知を送信
        log_message "wp-post processing completed successfully for site: $site_id"
        if send_slack_notification "$site_id" "$files_list"; then
            log_message "Slack notification completed for site: $site_id"
        else
            log_message "Slack notification failed for site: $site_id (but continuing)"
        fi
    fi
done

log_message "Post-commit hook completed successfully"
