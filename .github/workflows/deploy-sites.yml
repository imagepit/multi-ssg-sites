name: Deploy Documentation Sites

on:
  workflow_dispatch:
    inputs:
      site_id:
        description: "site-id to deploy (optional)"
        required: false
        type: string
      theme_id:
        description: "theme id (default: fumadocs)"
        required: false
        type: string
      production:
        description: "deploy as production"
        required: false
        type: boolean
        default: false
  push:
    branches: [main]
    paths:
      - "contents/**"
      - "images/**"
      - "theme/**"
      - "shared/**"
      - "scripts/**"
      - "package.json"
      - "pnpm-lock.yaml"
      - ".github/workflows/deploy-sites.yml"

jobs:
  detect-sites:
    runs-on: ubuntu-latest
    outputs:
      sites: ${{ steps.detect.outputs.sites }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect target sites
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.site_id }}" ]; then
            echo "sites=[\"${{ github.event.inputs.site_id }}\"]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BASE="${{ github.event.before }}"
          HEAD="${{ github.sha }}"
          if [ -z "$BASE" ] || [ "$BASE" = "0000000000000000000000000000000000000000" ]; then
            BASE="HEAD~1"
          fi

          sites=$(bash scripts/ci/detect-sites.sh "$BASE" "$HEAD")
          echo "sites=$sites" >> "$GITHUB_OUTPUT"

  deploy-site:
    needs: detect-sites
    if: ${{ needs.detect-sites.outputs.sites != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 4
      matrix:
        site: ${{ fromJson(needs.detect-sites.outputs.sites) }}
    steps:
      - name: Checkout (sparse)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          filter: blob:none
          sparse-checkout: |
            package.json
            pnpm-lock.yaml
            scripts
            theme
            shared
            contents/${{ matrix.site }}
            images

      - name: Enable corepack
        run: corepack enable

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Ensure Pages project exists
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          project_name="${{ matrix.site }}"
          exists=false

          if projects_json=$(wrangler pages project list --format json 2>/dev/null); then
            if node -e "const fs=require('fs');const name=process.argv[1];const data=JSON.parse(fs.readFileSync(0,'utf8'));process.exit(data.some((p)=>p.name===name)?0:1);" "$project_name" <<< "$projects_json"; then
              exists=true
            fi
          fi

          if [ "$exists" = "true" ]; then
            echo "Cloudflare Pages project already exists: ${project_name}"
            exit 0
          fi

          echo "Creating Cloudflare Pages project: ${project_name}"
          set +e
          create_output=$(wrangler pages project create "${project_name}" --production-branch main 2>&1)
          status=$?
          set -e
          if [ $status -ne 0 ]; then
            if echo "$create_output" | grep -qi "already exists"; then
              echo "Cloudflare Pages project already exists: ${project_name}"
            else
              echo "$create_output"
              exit $status
            fi
          fi

      - name: Build and deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          R2_BUCKET: ${{ secrets.R2_BUCKET }}
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_PUBLIC_BASE_URL: ${{ secrets.R2_PUBLIC_BASE_URL }}
          THEME_ID_INPUT: ${{ github.event.inputs.theme_id }}
          THEME_ID_VAR: ${{ vars.THEME_ID }}
          PRODUCTION_INPUT: ${{ github.event.inputs.production }}
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref }}
        run: |
          spec_path="contents/${{ matrix.site }}/specs/spec.json"
          theme_from_spec=""
          if [ -f "$spec_path" ]; then
            theme_from_spec=$(node -e "const fs=require('fs');const p=process.argv[1];try{const spec=JSON.parse(fs.readFileSync(p,'utf8'));console.log(spec.theme_id||spec.themeId||'');}catch{}" "$spec_path")
          fi

          theme_id="${THEME_ID_INPUT:-${THEME_ID_VAR:-fumadocs}}"
          if [ -z "$THEME_ID_INPUT" ] && [ -n "$theme_from_spec" ]; then
            theme_id="$theme_from_spec"
          fi
          production=false
          if [ "$EVENT_NAME" = "push" ] && [ "$REF_NAME" = "refs/heads/main" ]; then
            production=true
          fi
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ "$PRODUCTION_INPUT" = "true" ]; then
            production=true
          fi

          args=(deploy "${{ matrix.site }}" --theme "$theme_id")
          if [ "$production" = "true" ]; then
            args+=(--production)
          fi

          pnpm exec techdoc "${args[@]}"
