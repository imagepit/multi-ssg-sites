name: Deploy Documentation Sites

on:
  workflow_dispatch:
    inputs:
      site_id:
        description: "site-id to deploy (optional)"
        required: false
        type: string
      theme_id:
        description: "theme id (default: fumadocs)"
        required: false
        type: string
      production:
        description: "deploy as production"
        required: false
        type: boolean
        default: false
  push:
    branches: [main]
    paths:
      - "contents/**"
      - "images/**"
      - "theme/**"
      - "shared/**"
      - "scripts/**"
      - "package.json"
      - "pnpm-lock.yaml"
      - ".github/workflows/deploy-sites.yml"

jobs:
  detect-sites:
    runs-on: ubuntu-latest
    outputs:
      sites: ${{ steps.detect.outputs.sites }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect target sites
        id: detect
        run: |
          if [ -n "${{ github.event.inputs.site_id }}" ]; then
            echo "sites=[\"${{ github.event.inputs.site_id }}\"]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BASE="${{ github.event.before }}"
          HEAD="${{ github.sha }}"
          if [ -z "$BASE" ] || [ "$BASE" = "0000000000000000000000000000000000000000" ]; then
            BASE="HEAD~1"
          fi

          sites=$(bash scripts/ci/detect-sites.sh "$BASE" "$HEAD")
          echo "sites=$sites" >> "$GITHUB_OUTPUT"

  deploy-site:
    needs: detect-sites
    if: ${{ needs.detect-sites.outputs.sites != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 4
      fail-fast: false
      matrix:
        site: ${{ fromJson(needs.detect-sites.outputs.sites) }}
    steps:
      - name: Checkout (sparse)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          filter: blob:none
          sparse-checkout: |
            package.json
            pnpm-lock.yaml
            scripts
            theme
            shared
            contents/${{ matrix.site }}
            images

      - name: Enable corepack
        run: corepack enable

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install dependencies (skip postinstall)
        run: pnpm install --frozen-lockfile --ignore-scripts

      - name: Build shared fumadocs-engine
        run: pnpm build
        working-directory: shared/fumadocs-engine

      - name: Build scripts (techdoc CLI)
        run: pnpm build
        working-directory: scripts

      - name: Run theme postinstall scripts
        run: pnpm run --filter "./theme/*" postinstall

      - name: Install wrangler
        run: npm install -g wrangler

      - name: Ensure Pages project exists
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          project_name="${{ matrix.site }}"
          exists=false

          if projects_json=$(wrangler pages project list --format json 2>/dev/null); then
            if node -e "const fs=require('fs');const name=process.argv[1];const data=JSON.parse(fs.readFileSync(0,'utf8'));process.exit(data.some((p)=>p.name===name)?0:1);" "$project_name" <<< "$projects_json"; then
              exists=true
            fi
          fi

          if [ "$exists" = "true" ]; then
            echo "Cloudflare Pages project already exists: ${project_name}"
            exit 0
          fi

          echo "Creating Cloudflare Pages project: ${project_name}"
          set +e
          create_output=$(wrangler pages project create "${project_name}" --production-branch main 2>&1)
          status=$?
          set -e
          if [ $status -ne 0 ]; then
            if echo "$create_output" | grep -qi "already exists"; then
              echo "Cloudflare Pages project already exists: ${project_name}"
            else
              echo "$create_output"
              exit $status
            fi
          fi

      - name: Build and deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          R2_BUCKET: ${{ secrets.R2_BUCKET }}
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_PUBLIC_BASE_URL: ${{ secrets.R2_PUBLIC_BASE_URL }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
          ADMIN_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
          ADMIN_API_KEY: ${{ secrets.ADMIN_API_KEY }}
          THEME_ID_INPUT: ${{ github.event.inputs.theme_id }}
          THEME_ID_VAR: ${{ vars.THEME_ID }}
          PRODUCTION_INPUT: ${{ github.event.inputs.production }}
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref }}
        run: |
          spec_path="contents/${{ matrix.site }}/specs/spec.json"
          theme_from_spec=""
          if [ -f "$spec_path" ]; then
            theme_from_spec=$(node -e "const fs=require('fs');const p=process.argv[1];try{const spec=JSON.parse(fs.readFileSync(p,'utf8'));console.log(spec.theme_id||spec.themeId||'');}catch{}" "$spec_path")
          fi

          theme_id="${THEME_ID_INPUT:-${THEME_ID_VAR:-fumadocs}}"
          if [ -z "$THEME_ID_INPUT" ] && [ -n "$theme_from_spec" ]; then
            theme_id="$theme_from_spec"
          fi
          production=false
          if [ "$EVENT_NAME" = "push" ] && [ "$REF_NAME" = "refs/heads/main" ]; then
            production=true
          fi
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ "$PRODUCTION_INPUT" = "true" ]; then
            production=true
          fi

          args=(deploy "${{ matrix.site }}" --theme "$theme_id")
          if [ "$production" = "true" ]; then
            args+=(--production)
          fi

          # Sync products if ADMIN_API_KEY is configured
          if [ -n "$ADMIN_API_KEY" ]; then
            args+=(--sync-products)
          fi

          # Sync paid content to R2 if production
          if [ "$production" = "true" ]; then
            args+=(--sync-paid-content --env prod)
          fi

          node scripts/dist/presentation/cli.js "${args[@]}"

  notify:
    needs: [detect-sites, deploy-site]
    if: always() && needs.detect-sites.outputs.sites != '[]'
    runs-on: ubuntu-latest
    steps:
      - name: Notify Slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL is not set, skipping notification"
            exit 0
          fi

          RESULT="${{ needs.deploy-site.result }}"
          if [ "$RESULT" = "success" ]; then
            COLOR="#36a64f"
            EMOJI=":white_check_mark:"
            STATUS="成功"
          else
            COLOR="#dc3545"
            EMOJI=":x:"
            STATUS="失敗"
          fi

          curl -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d @- <<EOF
          {
            "attachments": [{
              "color": "$COLOR",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "$EMOJI *Deploy Documentation Sites* - $STATUS"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "<${{ github.server_url }}/${{ github.repository }}|${{ github.repository }}> | <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>"
                    }
                  ]
                }
              ]
            }]
          }
          EOF
