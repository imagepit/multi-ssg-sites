---
title: "å®Ÿè·µçš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼"
description: "Claude Codeã‚’æ´»ç”¨ã—ãŸãƒãƒ¼ãƒ é–‹ç™ºã®å®Ÿè·µçš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å­¦ã³ã¾ã™ã€‚ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒé–‹ç™ºã€ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã€ã‚³ãƒ¼ãƒ‰ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®å…·ä½“çš„ãªæ‰‹æ³•ã‚’ãƒã‚¹ã‚¿ãƒ¼ã—ã¾ã™ã€‚"
status: "published"
priority: "high"
tags: ["ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼", "ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒ", "ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°", "ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°"]
author: "Claude"
category: "team-development"
---

# å®Ÿè·µçš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼

Claude Codeã‚’æ´»ç”¨ã—ãŸãƒãƒ¼ãƒ é–‹ç™ºã®å®Ÿè·µçš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«ã¤ã„ã¦å­¦ã³ã¾ã™ã€‚ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€å®Ÿéš›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§å³åº§ã«æ´»ç”¨ã§ãã‚‹å…·ä½“çš„ãªé–‹ç™ºæ‰‹æ³•ã€ã‚³ãƒ©ãƒœãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®æœ€é©åŒ–ã€ãã—ã¦å“è³ªã‚’ç¶­æŒã—ãªãŒã‚‰ç”Ÿç”£æ€§ã‚’å‘ä¸Šã•ã›ã‚‹ãŸã‚ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’è§£èª¬ã—ã¾ã™ã€‚

## ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®é‡è¦æ€§

åŠ¹æœçš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã¯ã€ãƒãƒ¼ãƒ ã®ç”Ÿç”£æ€§ã¨ã‚³ãƒ¼ãƒ‰å“è³ªã‚’å¤§ããå·¦å³ã—ã¾ã™ã€‚Claude Codeã‚’é©åˆ‡ã«æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã‚’å¤§å¹…ã«æ”¹å–„ã§ãã¾ã™ã€‚

:::note åŠ¹æœçš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ç‰¹å¾´

- **ä¸€è²«æ€§**: ãƒãƒ¼ãƒ å…¨ä½“ã§çµ±ä¸€ã•ã‚ŒãŸé–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹
- **è‡ªå‹•åŒ–**: åå¾©çš„ãªã‚¿ã‚¹ã‚¯ã®è‡ªå‹•åŒ–ã«ã‚ˆã‚‹åŠ¹ç‡åŒ–
- **å¯è¦–åŒ–**: é€²æ—çŠ¶æ³ã‚„å•é¡Œç‚¹ã®æ˜ç¢ºãªå¯è¦–åŒ–
- **ç¶™ç¶šçš„æ”¹å–„**: å®šæœŸçš„ãªè¦‹ç›´ã—ã¨ãƒ—ãƒ­ã‚»ã‚¹ã®æ”¹å–„
- **å“è³ªä¿è¨¼**: å„æ®µéšã§ã®å“è³ªãƒã‚§ãƒƒã‚¯ã¨ãƒ¬ãƒ“ãƒ¥ãƒ¼

:::

## ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒé–‹ç™º

ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒé–‹ç™ºã¯ã€Gitã‚’ä½¿ã£ãŸåŠ¹æœçš„ãªãƒ–ãƒ©ãƒ³ãƒç®¡ç†æ‰‹æ³•ã§ã™ã€‚

:::step

1. ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒé–‹ç™ºã®ç’°å¢ƒæ§‹ç¯‰

ä»»æ„ã®å ´æ‰€ï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ãªã©ï¼‰ã§`feature-branch-workflow`ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆã—ã€å®Ÿè·µã‚’å§‹ã‚ã¾ã™ã€‚

```bash
mkdir feature-branch-workflow
cd feature-branch-workflow
git init
npm init -y
```

2. ãƒ–ãƒ©ãƒ³ãƒæˆ¦ç•¥ã®è¨­å®š

`.github/workflows/branch-protection.yml`ã‚’ä½œæˆã—ã€ãƒ–ãƒ©ãƒ³ãƒä¿è­·ãƒ«ãƒ¼ãƒ«ã‚’è¨­å®šã—ã¾ã™ã€‚

_.github/workflows/branch-protection.yml_

```yaml
name: Branch Protection

on:
  pull_request:
    branches: [ main, develop ]
  push:
    branches: [ main, develop ]

jobs:
  protect-main:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Check PR Requirements
      run: |
        echo "Checking if PR meets requirements..."
        # å®Ÿéš›ã«ã¯GitHubã®ãƒ–ãƒ©ãƒ³ãƒä¿è­·ãƒ«ãƒ¼ãƒ«ã‚’ä½¿ç”¨
        echo "âœ… All requirements checked"

  quality-check:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Run tests
      run: npm test

    - name: Check build
      run: npm run build
```

3. ãƒ–ãƒ©ãƒ³ãƒç®¡ç†ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…

`src/branch-manager.js`ã‚’ä½œæˆã—ã€Claude Codeã‚’æ´»ç”¨ã—ãŸãƒ–ãƒ©ãƒ³ãƒç®¡ç†ãƒ„ãƒ¼ãƒ«ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

_src/branch-manager.js_

```javascript
/**
 * Claude Codeã‚’æ´»ç”¨ã—ãŸãƒ–ãƒ©ãƒ³ãƒç®¡ç†ãƒ„ãƒ¼ãƒ«
 * ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒé–‹ç™ºã‚’åŠ¹ç‡åŒ–
 */
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class BranchManager {
  constructor() {
    this.branchTypes = {
      feature: 'feature/',
      bugfix: 'bugfix/',
      hotfix: 'hotfix/',
      release: 'release/',
      docs: 'docs/',
      refactor: 'refactor/'
    };
  }

  // ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒã®ä½œæˆ
  createFeatureBranch(featureName, description) {
    const branchName = `${this.branchTypes.feature}${featureName}`;

    // ãƒ–ãƒ©ãƒ³ãƒåã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!this.validateBranchName(branchName)) {
      throw new Error('ç„¡åŠ¹ãªãƒ–ãƒ©ãƒ³ãƒåã§ã™');
    }

    // ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒã‚’ç¢ºèª
    const currentBranch = this.getCurrentBranch();
    if (currentBranch !== 'develop') {
      throw new Error('developãƒ–ãƒ©ãƒ³ãƒã‹ã‚‰ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆã—ã¦ãã ã•ã„');
    }

    // ãƒ–ãƒ©ãƒ³ãƒã®ä½œæˆ
    try {
      execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });

      // ãƒ–ãƒ©ãƒ³ãƒæƒ…å ±ã®è¨˜éŒ²
      this.recordBranchInfo(branchName, {
        type: 'feature',
        name: featureName,
        description,
        createdAt: new Date().toISOString(),
        author: this.getCurrentAuthor(),
        status: 'in_progress'
      });

      console.log(`âœ… ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒã€Œ${branchName}ã€ã‚’ä½œæˆã—ã¾ã—ãŸ`);

      // Claude Codeã«ã‚ˆã‚‹åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      this.setupBranchEnvironment(branchName, description);

      return branchName;
    } catch (error) {
      console.error('âŒ ãƒ–ãƒ©ãƒ³ãƒã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      throw error;
    }
  }

  // ãƒ–ãƒ©ãƒ³ãƒã®ãƒãƒ¼ã‚¸
  mergeFeatureBranch(branchName, mergeType = 'merge') {
    const branchInfo = this.getBranchInfo(branchName);

    if (!branchInfo) {
      throw new Error('ãƒ–ãƒ©ãƒ³ãƒæƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    // å“è³ªãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œ
    if (!this.runQualityChecks(branchName)) {
      throw new Error('å“è³ªãƒã‚§ãƒƒã‚¯ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }

    // ãƒãƒ¼ã‚¸ã®å®Ÿè¡Œ
    try {
      switch (mergeType) {
        case 'merge':
          this.performMerge(branchName);
          break;
        case 'rebase':
          this.performRebase(branchName);
          break;
        case 'squash':
          this.performSquashMerge(branchName);
          break;
        default:
          throw new Error('ç„¡åŠ¹ãªãƒãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ã§ã™');
      }

      // ãƒ–ãƒ©ãƒ³ãƒæƒ…å ±ã®æ›´æ–°
      this.updateBranchStatus(branchName, 'merged');

      // å¾Œå‡¦ç†
      this.cleanupBranch(branchName);

      console.log(`âœ… ãƒ–ãƒ©ãƒ³ãƒã€Œ${branchName}ã€ã‚’ãƒãƒ¼ã‚¸ã—ã¾ã—ãŸ`);
    } catch (error) {
      console.error('âŒ ãƒãƒ¼ã‚¸ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      throw error;
    }
  }

  // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã®è§£æ¶ˆæ”¯æ´
  async resolveConflicts(branchName) {
    try {
      // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã®æ¤œå‡º
      const conflicts = this.detectConflicts(branchName);

      if (conflicts.length === 0) {
        console.log('âœ… ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“');
        return true;
      }

      console.log(`âš ï¸  ${conflicts.length}å€‹ã®ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ`);

      // Claude Codeã«ã‚ˆã‚‹ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ¶ˆã®ææ¡ˆ
      for (const conflict of conflicts) {
        const resolution = await this.generateConflictResolution(conflict);
        this.applyResolution(conflict, resolution);
      }

      console.log('âœ… ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã‚’è§£æ¶ˆã—ã¾ã—ãŸ');
      return true;
    } catch (error) {
      console.error('âŒ ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ¶ˆã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      return false;
    }
  }

  // ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ä½œæˆæ”¯æ´
  async createPullRequest(branchName, title, description) {
    const branchInfo = this.getBranchInfo(branchName);

    if (!branchInfo) {
      throw new Error('ãƒ–ãƒ©ãƒ³ãƒæƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    // å¤‰æ›´å†…å®¹ã®åˆ†æ
    const changes = this.analyzeChanges(branchName);

    // Claude Codeã«ã‚ˆã‚‹PRèª¬æ˜ã®ç”Ÿæˆ
    const prDescription = await this.generatePRDescription({
      branchName,
      title,
      description,
      changes,
      branchInfo
    });

    // ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ä½œæˆï¼ˆå®Ÿéš›ã«ã¯GitHub APIã‚’ä½¿ç”¨ï¼‰
    console.log('ğŸ“ ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆã—ã¾ã™...');
    console.log(`ã‚¿ã‚¤ãƒˆãƒ«: ${title}`);
    console.log(`èª¬æ˜:\n${prDescription}`);

    // ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã®è‡ªå‹•é¸æŠ
    const reviewers = this.selectReviewers(branchName, changes);
    console.log(`ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼: ${reviewers.join(', ')}`);

    return {
      title,
      description: prDescription,
      reviewers,
      branchName,
      targetBranch: 'develop'
    };
  }

  // ãƒ–ãƒ©ãƒ³ãƒç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
  setupBranchEnvironment(branchName, description) {
    console.log('ğŸ”§ ãƒ–ãƒ©ãƒ³ãƒç’°å¢ƒã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¾ã™...');

    // Claude Codeã«ã‚ˆã‚‹åˆæœŸãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ
    const prompt = `
æ–°ã—ã„ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒã€Œ${branchName}ã€ã‚’ä½œæˆã—ã¾ã™ã€‚
æ©Ÿèƒ½èª¬æ˜: ${description}

ã“ã®ãƒ–ãƒ©ãƒ³ãƒã§é–‹ç™ºã‚’å§‹ã‚ã‚‹ãŸã‚ã«å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆã¨åˆæœŸã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
è€ƒæ…®äº‹é …:
- ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®æº–å‚™
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
- é–‹ç™ºç’°å¢ƒã®è¨­å®š
- ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„ã®é©ç”¨
`;

    // å®Ÿéš›ã®Claude Code APIå‘¼ã³å‡ºã—ï¼ˆãƒ¢ãƒƒã‚¯ï¼‰
    this.generateBranchFiles(branchName, prompt);
  }

  // å“è³ªãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œ
  runQualityChecks(branchName) {
    console.log('ğŸ” å“è³ªãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™...');

    const checks = [
      'lint',
      'type-check',
      'test',
      'build',
      'security-scan'
    ];

    for (const check of checks) {
      try {
        execSync(`npm run ${check}`, { stdio: 'pipe' });
        console.log(`âœ… ${check} ã‚’ãƒ‘ã‚¹ã—ã¾ã—ãŸ`);
      } catch (error) {
        console.error(`âŒ ${check} ã«å¤±æ•—ã—ã¾ã—ãŸ`);
        return false;
      }
    }

    return true;
  }

  // å¤‰æ›´å†…å®¹ã®åˆ†æ
  analyzeChanges(branchName) {
    try {
      const diff = execSync(`git diff develop...${branchName}`, { encoding: 'utf8' });

      return {
        filesChanged: diff.split('\n').filter(line => line.startsWith('+++')).length,
        insertions: diff.split('\n').filter(line => line.startsWith('+') && !line.startsWith('+++')).length,
        deletions: diff.split('\n').filter(line => line.startsWith('-') && !line.startsWith('---')).length,
        linesChanged: diff.split('\n').length
      };
    } catch (error) {
      return { filesChanged: 0, insertions: 0, deletions: 0, linesChanged: 0 };
    }
  }

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
  validateBranchName(branchName) {
    return /^[a-z0-9\-\/]+$/.test(branchName);
  }

  getCurrentBranch() {
    return execSync('git branch --show-current', { encoding: 'utf8' }).trim();
  }

  getCurrentAuthor() {
    return execSync('git config user.name', { encoding: 'utf8' }).trim();
  }

  recordBranchInfo(branchName, info) {
    const branchInfoFile = path.join('.git', 'branch-info.json');
    let branchInfo = {};

    if (fs.existsSync(branchInfoFile)) {
      branchInfo = JSON.parse(fs.readFileSync(branchInfoFile, 'utf8'));
    }

    branchInfo[branchName] = info;
    fs.writeFileSync(branchInfoFile, JSON.stringify(branchInfo, null, 2));
  }

  getBranchInfo(branchName) {
    const branchInfoFile = path.join('.git', 'branch-info.json');

    if (!fs.existsSync(branchInfoFile)) {
      return null;
    }

    const branchInfo = JSON.parse(fs.readFileSync(branchInfoFile, 'utf8'));
    return branchInfo[branchName];
  }

  updateBranchStatus(branchName, status) {
    const branchInfoFile = path.join('.git', 'branch-info.json');
    const branchInfo = JSON.parse(fs.readFileSync(branchInfoFile, 'utf8'));

    if (branchInfo[branchName]) {
      branchInfo[branchName].status = status;
      branchInfo[branchName].updatedAt = new Date().toISOString();
    }

    fs.writeFileSync(branchInfoFile, JSON.stringify(branchInfo, null, 2));
  }

  detectConflicts(branchName) {
    try {
      const status = execSync('git status --porcelain', { encoding: 'utf8' });
      return status.split('\n')
        .filter(line => line.includes('UU') || line.includes('AA'))
        .map(line => line.trim());
    } catch (error) {
      return [];
    }
  }

  async generateConflictResolution(conflict) {
    // Claude Codeã«ã‚ˆã‚‹ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ¶ˆã®ææ¡ˆï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    return {
      resolution: 'auto-resolve',
      confidence: 0.8,
      explanation: 'è‡ªå‹•çš„ã«ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã‚’è§£æ¶ˆã—ã¾ã—ãŸ'
    };
  }

  applyResolution(conflict, resolution) {
    // å®Ÿéš›ã®è§£æ¶ˆå‡¦ç†ã‚’å®Ÿè£…
    console.log(`âœ… ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã‚’è§£æ¶ˆ: ${conflict}`);
  }

  async generatePRDescription(prData) {
    // Claude Codeã«ã‚ˆã‚‹PRèª¬æ˜ã®ç”Ÿæˆï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    return `
## å¤‰æ›´å†…å®¹
${prData.description}

## å¤‰æ›´ç‚¹
- å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«: ${prData.changes.filesChanged}å€‹
- è¿½åŠ è¡Œ: ${prData.changes.insertions}è¡Œ
- å‰Šé™¤è¡Œ: ${prData.changes.deletions}è¡Œ

## ãƒ†ã‚¹ãƒˆ
- [x] ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½
- [x] ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½
- [x] E2Eãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½

## ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
- ã‚³ãƒ¼ãƒ‰ã®ä¸€è²«æ€§
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¸ã®å½±éŸ¿
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®æ‡¸å¿µç‚¹
    `;
  }

  selectReviewers(branchName, changes) {
    // å®Ÿéš›ã®ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã‹ã‚‰é¸æŠã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    return ['reviewer1', 'reviewer2'];
  }

  performMerge(branchName) {
    execSync(`git merge ${branchName}`, { stdio: 'inherit' });
  }

  performRebase(branchName) {
    execSync(`git rebase ${branchName}`, { stdio: 'inherit' });
  }

  performSquashMerge(branchName) {
    execSync(`git merge --squash ${branchName}`, { stdio: 'inherit' });
    execSync('git commit -m "feat: squashed merge"', { stdio: 'inherit' });
  }

  cleanupBranch(branchName) {
    try {
      execSync(`git branch -d ${branchName}`, { stdio: 'inherit' });
    } catch (error) {
      console.warn('âš ï¸  ãƒ­ãƒ¼ã‚«ãƒ«ãƒ–ãƒ©ãƒ³ãƒã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }

  generateBranchFiles(branchName, prompt) {
    // Claude Codeã«ã‚ˆã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    console.log('ğŸ“ å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™...');

    const files = [
      '.gitignore',
      'README.md',
      'src/index.js',
      'tests/index.test.js'
    ];

    files.forEach(file => {
      if (!fs.existsSync(file)) {
        fs.writeFileSync(file, `// ${file} generated for ${branchName}\n`);
        console.log(`âœ… ${file} ã‚’ç”Ÿæˆã—ã¾ã—ãŸ`);
      }
    });
  }
}

module.exports = { BranchManager };
```

4. ä½¿ç”¨ä¾‹

`examples/feature-branch-example.js`ã‚’ä½œæˆã—ã€å®Ÿéš›ã®ä½¿ç”¨ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

_examples/feature-branch-example.js_

```javascript
const { BranchManager } = require('../src/branch-manager');

// ãƒ–ãƒ©ãƒ³ãƒãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
const branchManager = new BranchManager();

async function demonstrateFeatureBranchWorkflow() {
  console.log('ğŸš€ ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒé–‹ç™ºãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ãƒ‡ãƒ¢');
  console.log('=' .repeat(60));

  try {
    // 1. ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒã®ä½œæˆ
    console.log('\n1. ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒã®ä½œæˆ');
    const branchName = await branchManager.createFeatureBranch(
      'user-authentication',
      'ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼æ©Ÿèƒ½ã®å®Ÿè£…'
    );
    console.log(`âœ… ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ: ${branchName}`);

    // 2. é–‹ç™ºã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    console.log('\n2. é–‹ç™ºä½œæ¥­ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³');
    simulateDevelopment(branchName);

    // 3. å“è³ªãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œ
    console.log('\n3. å“è³ªãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œ');
    const qualityPassed = branchManager.runQualityChecks(branchName);
    if (qualityPassed) {
      console.log('âœ… å“è³ªãƒã‚§ãƒƒã‚¯ã‚’ãƒ‘ã‚¹ã—ã¾ã—ãŸ');
    }

    // 4. ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ä½œæˆ
    console.log('\n4. ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ä½œæˆ');
    const pr = await branchManager.createPullRequest(
      branchName,
      'feat: ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼æ©Ÿèƒ½ã®å®Ÿè£…',
      'JWTãƒ™ãƒ¼ã‚¹ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã—ã¾ã—ãŸ'
    );
    console.log('âœ… ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ');
    console.log(`ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼: ${pr.reviewers.join(', ')}`);

    // 5. ãƒ¬ãƒ“ãƒ¥ãƒ¼å¾Œã®ãƒãƒ¼ã‚¸
    console.log('\n5. ãƒ–ãƒ©ãƒ³ãƒã®ãƒãƒ¼ã‚¸');
    await branchManager.mergeFeatureBranch(branchName, 'merge');
    console.log('âœ… ãƒ–ãƒ©ãƒ³ãƒã‚’ãƒãƒ¼ã‚¸ã—ã¾ã—ãŸ');

    console.log('\nğŸ‰ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ãƒ‡ãƒ¢ãŒå®Œäº†ã—ã¾ã—ãŸï¼');

  } catch (error) {
    console.error('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error.message);
  }
}

function simulateDevelopment(branchName) {
  console.log('ğŸ“ é–‹ç™ºä½œæ¥­ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¾ã™...');

  // ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆ
  const fs = require('fs');

  // èªè¨¼æ©Ÿèƒ½ã®å®Ÿè£…
  const authCode = `
class AuthService {
  constructor() {
    this.users = new Map();
  }

  async login(username, password) {
    // èªè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…
    const user = this.users.get(username);
    if (user && user.password === password) {
      return { success: true, token: 'jwt-token' };
    }
    return { success: false, error: 'Invalid credentials' };
  }

  async register(username, password) {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ãƒ­ã‚¸ãƒƒã‚¯
    if (this.users.has(username)) {
      return { success: false, error: 'User already exists' };
    }
    this.users.set(username, { password });
    return { success: true };
  }
}

module.exports = { AuthService };
`;

  fs.writeFileSync('src/AuthService.js', authCode);
  console.log('âœ… èªè¨¼æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¾ã—ãŸ');

  // ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆ
  const testCode = `
const { AuthService } = require('../src/AuthService');

describe('AuthService', () => {
  let authService;

  beforeEach(() => {
    authService = new AuthService();
  });

  test('should register new user', async () => {
    const result = await authService.register('testuser', 'password123');
    expect(result.success).toBe(true);
  });

  test('should login with valid credentials', async () => {
    await authService.register('testuser', 'password123');
    const result = await authService.login('testuser', 'password123');
    expect(result.success).toBe(true);
  });
});
`;

  fs.writeFileSync('tests/AuthService.test.js', testCode);
  console.log('âœ… ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ');

  // Gitã‚³ãƒŸãƒƒãƒˆ
  const { execSync } = require('child_process');
  execSync('git add .', { stdio: 'inherit' });
  execSync('git commit -m "feat: implement user authentication"', { stdio: 'inherit' });
  console.log('âœ… å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆã—ã¾ã—ãŸ');
}

// ãƒ‡ãƒ¢ã®å®Ÿè¡Œ
demonstrateFeatureBranchWorkflow().catch(console.error);
```

:::

## ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°

ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯ã€2äººã®é–‹ç™ºè€…ãŒ1å°ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§å…±åŒä½œæ¥­ã™ã‚‹é–‹ç™ºæ‰‹æ³•ã§ã™ã€‚

:::step

1. ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ”¯æ´ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…

`src/pair-programming.js`ã‚’ä½œæˆã—ã€Claude Codeã‚’æ´»ç”¨ã—ãŸãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ”¯æ´ãƒ„ãƒ¼ãƒ«ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

_src/pair-programming.js_

```javascript
/**
 * Claude Codeã‚’æ´»ç”¨ã—ãŸãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ”¯æ´ãƒ„ãƒ¼ãƒ«
 */
class PairProgrammingAssistant {
  constructor() {
    this.session = {
      driver: null,
      navigator: null,
      startTime: null,
      tasks: [],
      notes: [],
      codeReviews: []
    };
  }

  // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®é–‹å§‹
  startSession(driver, navigator, task) {
    this.session = {
      driver,
      navigator,
      startTime: new Date(),
      tasks: [task],
      notes: [],
      codeReviews: [],
      currentFile: null,
      currentLine: null
    };

    console.log(`ğŸš€ ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‹å§‹`);
    console.log(`ğŸ‘¨â€ğŸ’» ãƒ‰ãƒ©ã‚¤ãƒãƒ¼: ${driver}`);
    console.log(`ğŸ§­ ãƒŠãƒ“ã‚²ãƒ¼ã‚¿ãƒ¼: ${navigator}`);
    console.log(`ğŸ“ ã‚¿ã‚¹ã‚¯: ${task}`);

    // Claude Codeã«ã‚ˆã‚‹ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æœ€é©åŒ–
    this.optimizeSession();
  }

  // ã‚³ãƒ¼ãƒ‰ã®åˆ†æã¨ææ¡ˆ
  async analyzeCode(code, context) {
    const analysis = {
      quality: 0,
      suggestions: [],
      potentialIssues: [],
      improvements: []
    };

    // ã‚³ãƒ¼ãƒ‰å“è³ªã®åˆ†æ
    analysis.quality = this.calculateCodeQuality(code);

    // æ½œåœ¨çš„ãªå•é¡Œã®æ¤œå‡º
    analysis.potentialIssues = this.detectPotentialIssues(code);

    // æ”¹å–„ææ¡ˆã®ç”Ÿæˆ
    analysis.improvements = await this.generateImprovements(code, context);

    return analysis;
  }

  // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼
  async performRealtimeReview(code, line) {
    const review = {
      line,
      timestamp: new Date(),
      suggestions: [],
      warnings: [],
      bestPractices: []
    };

    // Claude Codeã«ã‚ˆã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¬ãƒ“ãƒ¥ãƒ¼
    const prompt = `
ç¾åœ¨ã®è¡Œ: ${line}
ã‚³ãƒ¼ãƒ‰ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ:
${code}

ã“ã®è¡Œã«ã¤ã„ã¦ä»¥ä¸‹ã®ç‚¹ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦ãã ã•ã„:
1. ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§
2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¸ã®å½±éŸ¿
3. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®æ‡¸å¿µ
4. ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã®éµå®ˆ
5. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®æ©Ÿä¼š
`;

    const claudeResponse = await this.callClaudeCode(prompt);
    review.suggestions = claudeResponse.suggestions || [];
    review.warnings = claudeResponse.warnings || [];
    review.bestPractices = claudeResponse.bestPractices || [];

    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«è¨˜éŒ²
    this.session.codeReviews.push(review);

    return review;
  }

  // ãƒŠãƒ¬ãƒƒã‚¸ã®å…±æœ‰ã¨è¨˜éŒ²
  recordKnowledge(topic, content, type = 'technique') {
    const knowledge = {
      topic,
      content,
      type,
      timestamp: new Date(),
      sharedBy: this.session.navigator
    };

    this.session.notes.push(knowledge);

    // ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã¸ã®ä¿å­˜
    this.saveToKnowledgeBase(knowledge);

    console.log(`ğŸ“š ãƒŠãƒ¬ãƒƒã‚¸ã‚’è¨˜éŒ²: ${topic}`);
  }

  // ã‚¿ã‚¹ã‚¯ã®é€²æ—ç®¡ç†
  updateTaskProgress(taskId, progress, notes) {
    const task = this.session.tasks.find(t => t.id === taskId);
    if (task) {
      task.progress = progress;
      task.notes = notes;
      task.updatedAt = new Date();

      // é€²æ—ã«åŸºã¥ã„ã¦Claude Codeã«ææ¡ˆã‚’ä¾é ¼
      if (progress % 25 === 0) {
        this.requestProgressSuggestions(task);
      }
    }
  }

  // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æœ€é©åŒ–
  optimizeSession() {
    // ä½œæ¥­ã‚¹ã‚¿ã‚¤ãƒ«ã®åˆ†æ
    const style = this.analyzeWorkingStyle();

    // æœ€é©ãªãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ææ¡ˆ
    const rotationTime = this.suggestRotationTime(style);

    // åŠ¹ç‡çš„ãªã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ–¹æ³•ã®ææ¡ˆ
    const communicationTips = this.suggestCommunicationTips(style);

    console.log('ğŸ”§ ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’æœ€é©åŒ–ã—ã¾ã™...');
    console.log(`ğŸ”„ æ¨å¥¨ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³é–“éš”: ${rotationTime}åˆ†`);
    console.log(`ğŸ’¡ ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ’ãƒ³ãƒˆ: ${communicationTips}`);
  }

  // ã‚³ãƒ¼ãƒ‰å“è³ªã®è¨ˆç®—
  calculateCodeQuality(code) {
    let quality = 100;

    // è¤‡é›‘æ€§ã®ãƒã‚§ãƒƒã‚¯
    const complexity = this.analyzeComplexity(code);
    quality -= complexity * 5;

    // å‘½åè¦å‰‡ã®ãƒã‚§ãƒƒã‚¯
    const namingScore = this.checkNamingConventions(code);
    quality -= (100 - namingScore) * 0.3;

    // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ãƒã‚§ãƒƒã‚¯
    const documentationScore = this.checkDocumentation(code);
    quality -= (100 - documentationScore) * 0.2;

    return Math.max(0, Math.min(100, quality));
  }

  // æ½œåœ¨çš„ãªå•é¡Œã®æ¤œå‡º
  detectPotentialIssues(code) {
    const issues = [];
    const lines = code.split('\n');

    lines.forEach((line, index) => {
      const lineNumber = index + 1;

      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å•é¡Œ
      if (line.includes('eval(')) {
        issues.push({
          type: 'security',
          line: lineNumber,
          message: 'eval()ã®ä½¿ç”¨ã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ãŒã‚ã‚Šã¾ã™',
          severity: 'high'
        });
      }

      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œ
      if (line.includes('innerHTML')) {
        issues.push({
          type: 'performance',
          line: lineNumber,
          message: 'innerHTMLã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å½±éŸ¿ã—ã¾ã™',
          severity: 'medium'
        });
      }

      // ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡
      if (line.trim().length > 100) {
        issues.push({
          type: 'readability',
          line: lineNumber,
          message: 'è¡ŒãŒé•·ã™ãã¾ã™ã€‚åˆ†å‰²ã‚’æ¤œè¨ã—ã¦ãã ã•ã„',
          severity: 'low'
        });
      }
    });

    return issues;
  }

  // æ”¹å–„ææ¡ˆã®ç”Ÿæˆ
  async generateImprovements(code, context) {
    const prompt = `
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã®æ”¹å–„ææ¡ˆã‚’ç”Ÿæˆã—ã¦ãã ã•ã„:

ã‚³ãƒ¼ãƒ‰:
${code}

ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ:
${JSON.stringify(context, null, 2)}

æ”¹å–„ç‚¹ã®è¦³ç‚¹:
1. å¯èª­æ€§ã®å‘ä¸Š
2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æœ€é©åŒ–
3. ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§ã®æ”¹å–„
4. ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã®å‘ä¸Š
5. ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã®é©ç”¨
`;

    const response = await this.callClaudeCode(prompt);
    return response.improvements || [];
  }

  // ä½œæ¥­ã‚¹ã‚¿ã‚¤ãƒ«ã®åˆ†æ
  analyzeWorkingStyle() {
    // å®Ÿéš›ã«ã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸­ã®è¡Œå‹•ã‚’åˆ†æ
    return {
      pace: 'moderate',
      communication: 'frequent',
      problemSolving: 'collaborative',
      focus: 'balanced'
    };
  }

  // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ææ¡ˆ
  suggestRotationTime(style) {
    const baseTime = 25; // ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’ãƒ™ãƒ¼ã‚¹ã«

    switch (style.pace) {
      case 'fast': return 15;
      case 'slow': return 35;
      default: return baseTime;
    }
  }

  // ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ’ãƒ³ãƒˆ
  suggestCommunicationTips(style) {
    const tips = [];

    if (style.communication === 'infrequent') {
      tips.push('ã‚ˆã‚Šé »ç¹ã«ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å–ã‚Šã¾ã—ã‚‡ã†');
    }

    if (style.problemSolving === 'individual') {
      tips.push('å•é¡Œè§£æ±ºã¯å…±åŒã§å–ã‚Šçµ„ã‚€ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†');
    }

    return tips.join(', ');
  }

  // é€²æ—ã«åŸºã¥ã„ãŸææ¡ˆã®è¦æ±‚
  async requestProgressSuggestions(task) {
    const prompt = `
ã‚¿ã‚¹ã‚¯ã®é€²æ—ãŒ${task.progress}%å®Œäº†ã—ã¾ã—ãŸã€‚
æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã«é–¢ã™ã‚‹ææ¡ˆã‚’ã—ã¦ãã ã•ã„:

ã‚¿ã‚¹ã‚¯: ${task.name}
ç¾åœ¨ã®é€²æ—: ${task.progress}%
ãƒ¡ãƒ¢: ${task.notes}

ææ¡ˆå†…å®¹:
1. æ¬¡ã«å–ã‚Šçµ„ã‚€ã¹ãä½œæ¥­
2. æ½œåœ¨çš„ãªå•é¡Œç‚¹
3. å“è³ªå‘ä¸Šã®ãƒ’ãƒ³ãƒˆ
4. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥
`;

    const suggestions = await this.callClaudeCode(prompt);
    console.log('ğŸ’¡ é€²æ—ã«åŸºã¥ã„ãŸææ¡ˆ:');
    suggestions.forEach(suggestion => {
      console.log(`  - ${suggestion}`);
    });
  }

  // ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã¸ã®ä¿å­˜
  saveToKnowledgeBase(knowledge) {
    // å®Ÿéš›ã«ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚„ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    const knowledgeBase = this.loadKnowledgeBase();
    knowledgeBase.push(knowledge);
    this.saveKnowledgeBase(knowledgeBase);
  }

  // ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿
  loadKnowledgeBase() {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚„DBã‹ã‚‰èª­ã¿è¾¼ã‚€
    return [];
  }

  // ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã®ä¿å­˜
  saveKnowledgeBase(knowledgeBase) {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚„DBã«ä¿å­˜
  }

  // Claude Code APIã®å‘¼ã³å‡ºã—ï¼ˆãƒ¢ãƒƒã‚¯ï¼‰
  async callClaudeCode(prompt) {
    // å®Ÿéš›ã®Claude Code APIå‘¼ã³å‡ºã—ã‚’å®Ÿè£…
    return {
      suggestions: ['ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ã‚’å‘ä¸Šã•ã›ã‚‹ãŸã‚ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ ã—ã¾ã—ã‚‡ã†'],
      warnings: [],
      improvements: ['é–¢æ•°ã‚’åˆ†å‰²ã—ã¦å˜ä¸€è²¬ä»»ã®åŸå‰‡ã‚’é©ç”¨'],
      bestPractices: ['ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã‚’80%ä»¥ä¸Šã«ä¿ã¡ã¾ã—ã‚‡ã†']
    };
  }

  // è¤‡é›‘æ€§ã®åˆ†æ
  analyzeComplexity(code) {
    // ç°¡æ˜“çš„ãªè¤‡é›‘æ€§åˆ†æ
    const lines = code.split('\n');
    let complexity = 0;

    lines.forEach(line => {
      if (line.match(/\b(if|else|for|while|switch|case)\b/)) {
        complexity++;
      }
    });

    return complexity;
  }

  // å‘½åè¦å‰‡ã®ãƒã‚§ãƒƒã‚¯
  checkNamingConventions(code) {
    // ç°¡æ˜“çš„ãªå‘½åè¦å‰‡ãƒã‚§ãƒƒã‚¯
    const lines = code.split('\n');
    let score = 100;

    lines.forEach(line => {
      if (line.match(/\b(let|const)\s+[A-Z]/)) {
        score -= 10;
      }
    });

    return Math.max(0, score);
  }

  // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ãƒã‚§ãƒƒã‚¯
  checkDocumentation(code) {
    // ç°¡æ˜“çš„ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
    const lines = code.split('\n');
    let hasComments = false;

    lines.forEach(line => {
      if (line.trim().startsWith('//') || line.trim().startsWith('/*')) {
        hasComments = true;
      }
    });

    return hasComments ? 100 : 0;
  }

  // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®çµ‚äº†
  endSession() {
    const duration = new Date() - this.session.startTime;
    const minutes = Math.floor(duration / 60000);

    console.log(`\nğŸ ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’çµ‚äº†`);
    console.log(`â±ï¸  æ‰€è¦æ™‚é–“: ${minutes}åˆ†`);
    console.log(`ğŸ“ å®Œäº†ã‚¿ã‚¹ã‚¯: ${this.session.tasks.filter(t => t.progress === 100).length}`);
    console.log(`ğŸ“š è¨˜éŒ²ã•ã‚ŒãŸãƒŠãƒ¬ãƒƒã‚¸: ${this.session.notes.length}ä»¶`);
    console.log(`ğŸ” ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼: ${this.session.codeReviews.length}ä»¶`);

    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
    const report = this.generateSessionReport();
    console.log('\nğŸ“Š ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆ:');
    console.log(report);

    return {
      duration,
      tasksCompleted: this.session.tasks.filter(t => t.progress === 100).length,
      knowledgeShared: this.session.notes.length,
      reviewsPerformed: this.session.codeReviews.length
    };
  }

  // ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
  generateSessionReport() {
    const report = {
      session: {
        driver: this.session.driver,
        navigator: this.session.navigator,
        duration: new Date() - this.session.startTime,
        tasksCompleted: this.session.tasks.filter(t => t.progress === 100).length
      },
      knowledge: {
        shared: this.session.notes.length,
        topics: this.session.notes.map(n => n.topic)
      },
      quality: {
        reviews: this.session.codeReviews.length,
        suggestions: this.session.codeReviews.reduce((sum, r) => sum + r.suggestions.length, 0)
      }
    };

    return JSON.stringify(report, null, 2);
  }
}

module.exports = { PairProgrammingAssistant };
```

2. ä½¿ç”¨ä¾‹

`examples/pair-programming-example.js`ã‚’ä½œæˆã—ã¾ã™ã€‚

_examples/pair-programming-example.js_

```javascript
const { PairProgrammingAssistant } = require('../src/pair-programming');

// ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®åˆæœŸåŒ–
const assistant = new PairProgrammingAssistant();

async function demonstratePairProgramming() {
  console.log('ğŸ¤ ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ãƒ‡ãƒ¢');
  console.log('=' .repeat(60));

  try {
    // 1. ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®é–‹å§‹
    console.log('\n1. ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®é–‹å§‹');
    assistant.startSession(
      'å±±ç”°å¤ªéƒ',
      'ä½è—¤èŠ±å­',
      'ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼æ©Ÿèƒ½ã®å®Ÿè£…'
    );

    // 2. ã‚³ãƒ¼ãƒ‰ã®åˆ†æ
    console.log('\n2. ã‚³ãƒ¼ãƒ‰ã®åˆ†æ');
    const code = `
class UserService {
  constructor() {
    this.users = [];
  }

  addUser(user) {
    this.users.push(user);
    return user;
  }

  getUser(id) {
    return this.users.find(u => u.id === id);
  }
}
`;

    const analysis = await assistant.analyzeCode(code, {
      context: 'user authentication system',
      language: 'javascript'
    });

    console.log('ğŸ“Š ã‚³ãƒ¼ãƒ‰å“è³ªã‚¹ã‚³ã‚¢:', analysis.quality);
    console.log('ğŸ” æ½œåœ¨çš„ãªå•é¡Œ:', analysis.potentialIssues.length);
    console.log('ğŸ’¡ æ”¹å–„ææ¡ˆ:', analysis.improvements.length);

    // 3. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¬ãƒ“ãƒ¥ãƒ¼
    console.log('\n3. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼');
    const review = await assistant.performRealtimeReview(
      code,
      'this.users.push(user);'
    );

    console.log('ğŸ“ ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ:');
    console.log('  ææ¡ˆ:', review.suggestions.length);
    console.log('  è­¦å‘Š:', review.warnings.length);
    console.log('  ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹:', review.bestPractices.length);

    // 4. ãƒŠãƒ¬ãƒƒã‚¸ã®å…±æœ‰
    console.log('\n4. ãƒŠãƒ¬ãƒƒã‚¸ã®å…±æœ‰');
    assistant.recordKnowledge(
      'ä¾å­˜æ€§æ³¨å…¥',
      'UserServiceã¯ä¾å­˜æ€§æ³¨å…¥ã‚’ä½¿ã£ã¦ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã‚’å‘ä¸Šã•ã›ã‚‹ã¹ãã§ã™',
      'pattern'
    );

    assistant.recordKnowledge(
      'ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°',
      'addUserãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå¿…è¦ã§ã™',
      'technique'
    );

    // 5. é€²æ—ã®æ›´æ–°
    console.log('\n5. é€²æ—ã®æ›´æ–°');
    assistant.updateTaskProgress(
      assistant.session.tasks[0].id,
      50,
      'åŸºæœ¬çš„ãªã‚¯ãƒ©ã‚¹æ§‹é€ ã‚’å®Ÿè£…å®Œäº†'
    );

    // 6. ã•ã‚‰ã«é–‹ç™ºã‚’é€²ã‚ã‚‹
    console.log('\n6. é–‹ç™ºã®ç¶™ç¶š');
    await simulateFurtherDevelopment(assistant);

    // 7. ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®çµ‚äº†
    console.log('\n7. ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®çµ‚äº†');
    const results = assistant.endSession();

    console.log('\nğŸ‰ ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ‡ãƒ¢ãŒå®Œäº†ã—ã¾ã—ãŸï¼');
    console.log('ğŸ“ˆ çµæœ:');
    console.log(`  - æ‰€è¦æ™‚é–“: ${Math.floor(results.duration / 60000)}åˆ†`);
    console.log(`  - å®Œäº†ã‚¿ã‚¹ã‚¯: ${results.tasksCompleted}`);
    console.log(`  - å…±æœ‰ãƒŠãƒ¬ãƒƒã‚¸: ${results.knowledgeShared}`);
    console.log(`  - ãƒ¬ãƒ“ãƒ¥ãƒ¼å›æ•°: ${results.reviewsPerformed}`);

  } catch (error) {
    console.error('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error.message);
  }
}

async function simulateFurtherDevelopment(assistant) {
  console.log('ğŸ”§ é–‹ç™ºã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¾ã™...');

  // ãƒ†ã‚¹ãƒˆã®è¿½åŠ 
  assistant.recordKnowledge(
    'ãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™º',
    'å®Ÿè£…å‰ã«ãƒ†ã‚¹ãƒˆã‚’æ›¸ãã“ã¨ã§å“è³ªã‚’ç¢ºä¿',
    'methodology'
  );

  // ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®ææ¡ˆ
  assistant.recordKnowledge(
    'ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°',
    'å˜ä¸€è²¬ä»»ã®åŸå‰‡ã«å¾“ã£ã¦ã‚¯ãƒ©ã‚¹ã‚’åˆ†å‰²',
    'technique'
  );

  // é€²æ—ã®æ›´æ–°
  assistant.updateTaskProgress(
    assistant.session.tasks[0].id,
    75,
    'ãƒ†ã‚¹ãƒˆã¨ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’å®Ÿæ–½'
  );

  // æœ€çµ‚çš„ãªã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼
  const finalCode = `
class UserService {
  constructor(database) {
    this.db = database;
  }

  async addUser(userData) {
    if (!userData.name || !userData.email) {
      throw new Error('Name and email are required');
    }

    const user = {
      id: Date.now(),
      ...userData,
      createdAt: new Date()
    };

    await this.db.insert('users', user);
    return user;
  }

  async getUser(id) {
    const user = await this.db.findById('users', id);
    if (!user) {
      throw new Error('User not found');
    }
    return user;
  }
}
`;

  const finalReview = await assistant.analyzeCode(finalCode, {
    context: 'refactored user service',
    language: 'javascript'
  });

  console.log('ğŸ† æœ€çµ‚çš„ãªã‚³ãƒ¼ãƒ‰å“è³ª:', finalReview.quality);

  // é€²æ—ã®å®Œäº†
  assistant.updateTaskProgress(
    assistant.session.tasks[0].id,
    100,
    'ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã¨ãƒ†ã‚¹ãƒˆãŒå®Œäº†'
  );
}

// ãƒ‡ãƒ¢ã®å®Ÿè¡Œ
demonstratePairProgramming().catch(console.error);
```

:::

## ã‚³ãƒ¼ãƒ‰ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°

ã‚³ãƒ¼ãƒ‰ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã¯ã€å¤–éƒ¨ã®æŒ¯ã‚‹èˆã„ã‚’å¤‰æ›´ã›ãšã«ã‚³ãƒ¼ãƒ‰ã®å†…éƒ¨æ§‹é€ ã‚’æ”¹å–„ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã§ã™ã€‚

:::step

1. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ”¯æ´ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…

`src/refactoring-assistant.js`ã‚’ä½œæˆã—ã€Claude Codeã‚’æ´»ç”¨ã—ãŸãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ”¯æ´ãƒ„ãƒ¼ãƒ«ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

_src/refactoring-assistant.js_

```javascript
/**
 * Claude Codeã‚’æ´»ç”¨ã—ãŸã‚³ãƒ¼ãƒ‰ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ”¯æ´ãƒ„ãƒ¼ãƒ«
 */
class RefactoringAssistant {
  constructor() {
    this.refactoringHistory = [];
    this.metrics = {
      complexity: 0,
      maintainability: 0,
      testability: 0,
      duplications: 0
    };
  }

  // ã‚³ãƒ¼ãƒ‰ã®åˆ†æ
  async analyzeCode(code) {
    const analysis = {
      complexity: this.calculateComplexity(code),
      maintainability: this.calculateMaintainability(code),
      testability: this.calculateTestability(code),
      duplications: this.findDuplications(code),
      smells: this.detectCodeSmells(code),
      suggestions: []
    };

    // Claude Codeã«ã‚ˆã‚‹æ”¹å–„ææ¡ˆ
    analysis.suggestions = await this.generateRefactoringSuggestions(analysis);

    return analysis;
  }

  // è‡ªå‹•ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®å®Ÿè¡Œ
  async performRefactoring(code, refactorings) {
    let refactoredCode = code;
    const appliedRefactorings = [];

    for (const refactoring of refactorings) {
      try {
        const result = await this.applyRefactoring(refactoredCode, refactoring);
        if (result.success) {
          refactoredCode = result.code;
          appliedRefactorings.push({
            ...refactoring,
            appliedAt: new Date()
          });
        } else {
          console.warn(`âš ï¸  ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¤±æ•—: ${refactoring.type}`);
        }
      } catch (error) {
        console.error(`âŒ ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼: ${error.message}`);
      }
    }

    return {
      code: refactoredCode,
      appliedRefactorings,
      metrics: this.calculateMetrics(refactoredCode)
    };
  }

  // æ®µéšçš„ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®è¨ˆç”»
  createRefactoringPlan(analysis) {
    const plan = {
      phases: [],
      estimatedTime: 0,
      risks: [],
      prerequisites: []
    };

    // å„ªå…ˆåº¦ã«åŸºã¥ã„ãŸãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®è¨ˆç”»
    const highPriority = analysis.suggestions.filter(s => s.priority === 'high');
    const mediumPriority = analysis.suggestions.filter(s => s.priority === 'medium');
    const lowPriority = analysis.suggestions.filter(s => s.priority === 'low');

    // ãƒ•ã‚§ãƒ¼ã‚º1: ç·Šæ€¥ã®å•é¡Œä¿®æ­£
    if (highPriority.length > 0) {
      plan.phases.push({
        name: 'ç·Šæ€¥ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°',
        refactorings: highPriority,
        estimatedTime: this.estimateTime(highPriority),
        description: 'å“è³ªã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«å½±éŸ¿ã™ã‚‹ç·Šæ€¥ã®å•é¡Œã‚’ä¿®æ­£'
      });
    }

    // ãƒ•ã‚§ãƒ¼ã‚º2: æ§‹é€ ã®æ”¹å–„
    if (mediumPriority.length > 0) {
      plan.phases.push({
        name: 'æ§‹é€ æ”¹å–„',
        refactorings: mediumPriority,
        estimatedTime: this.estimateTime(mediumPriority),
        description: 'ã‚³ãƒ¼ãƒ‰ã®æ§‹é€ ã¨è¨­è¨ˆã‚’æ”¹å–„'
      });
    }

    // ãƒ•ã‚§ãƒ¼ã‚º3: å¾®èª¿æ•´
    if (lowPriority.length > 0) {
      plan.phases.push({
        name: 'å¾®èª¿æ•´',
        refactorings: lowPriority,
        estimatedTime: this.estimateTime(lowPriority),
        description: 'å¯èª­æ€§ã¨ä¿å®ˆæ€§ã®å‘ä¸Š'
      });
    }

    plan.estimatedTime = plan.phases.reduce((sum, phase) => sum + phase.estimatedTime, 0);

    return plan;
  }

  // ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®å®‰å…¨æ€§æ¤œè¨¼
  validateRefactoring(originalCode, refactoredCode, tests) {
    const validation = {
      isSafe: true,
      issues: [],
      testResults: null,
      performanceImpact: null
    };

    // æ§‹æ–‡ãƒã‚§ãƒƒã‚¯
    try {
      // å®Ÿéš›ã®è¨€èªã«å¿œã˜ãŸæ§‹æ–‡ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè£…
      validation.issues.push(...this.checkSyntax(refactoredCode));
    } catch (error) {
      validation.isSafe = false;
      validation.issues.push({
        type: 'syntax',
        message: 'æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ',
        details: error.message
      });
    }

    // æ„å‘³çš„ãªç­‰ä¾¡æ€§ãƒã‚§ãƒƒã‚¯
    const semanticValidation = this.checkSemanticEquivalence(originalCode, refactoredCode);
    validation.issues.push(...semanticValidation.issues);

    // ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œï¼ˆãƒ†ã‚¹ãƒˆãŒæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
    if (tests) {
      validation.testResults = this.runTests(refactoredCode, tests);
      if (!validation.testResults.passed) {
        validation.isSafe = false;
        validation.issues.push({
          type: 'test',
          message: 'ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¾ã—ãŸ',
          details: validation.testResults.failures
        });
      }
    }

    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å½±éŸ¿ã®è©•ä¾¡
    validation.performanceImpact = this.assessPerformanceImpact(originalCode, refactoredCode);

    return validation;
  }

  // è¤‡é›‘æ€§ã®è¨ˆç®—
  calculateComplexity(code) {
    let complexity = 1; // åŸºæœ¬è¤‡é›‘æ€§
    const lines = code.split('\n');

    lines.forEach(line => {
      // åˆ¶å¾¡æ§‹é€ ã®ã‚«ã‚¦ãƒ³ãƒˆ
      if (line.match(/\b(if|else if|while|for|switch|catch)\b/)) {
        complexity++;
      }

      // è«–ç†æ¼”ç®—å­ã®ã‚«ã‚¦ãƒ³ãƒˆ
      const logicalOps = (line.match(/&&|\|\|/g) || []).length;
      complexity += logicalOps;

      // ä¸‰é …æ¼”ç®—å­ã®ã‚«ã‚¦ãƒ³ãƒˆ
      if (line.match(/\?/)) {
        complexity += 0.5;
      }
    });

    return Math.round(complexity);
  }

  // ä¿å®ˆæ€§ã®è¨ˆç®—
  calculateMaintainability(code) {
    let score = 100;
    const lines = code.split('\n');

    // è¡Œã®é•·ã•
    lines.forEach(line => {
      if (line.length > 100) {
        score -= 2;
      }
    });

    // é–¢æ•°ã®é•·ã•
    const functions = this.extractFunctions(code);
    functions.forEach(func => {
      if (func.lines > 50) {
        score -= 5;
      } else if (func.lines > 25) {
        score -= 2;
      }
    });

    // ã‚³ãƒ¡ãƒ³ãƒˆã®å‰²åˆ
    const commentLines = lines.filter(line =>
      line.trim().startsWith('//') || line.trim().startsWith('/*')
    ).length;
    const commentRatio = commentLines / lines.length;
    if (commentRatio < 0.1) {
      score -= 10;
    }

    return Math.max(0, score);
  }

  // ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã®è¨ˆç®—
  calculateTestability(code) {
    let score = 100;
    const lines = code.split('\n');

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«çŠ¶æ…‹ã®ä½¿ç”¨
    if (code.match(/global\b/)) {
      score -= 20;
    }

    // ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸä¾å­˜é–¢ä¿‚
    if (code.match(/new\s+\w+\s*\(/)) {
      score -= 15;
    }

    // é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã®å¤šç”¨
    const staticMethods = (code.match(/static\s+\w+/g) || []).length;
    score -= Math.min(staticMethods * 5, 20);

    // å˜ä¸€è²¬ä»»ã®åŸå‰‡
    const functions = this.extractFunctions(code);
    functions.forEach(func => {
      if (func.responsibilities > 3) {
        score -= 10;
      }
    });

    return Math.max(0, score);
  }

  // é‡è¤‡ã‚³ãƒ¼ãƒ‰ã®æ¤œå‡º
  findDuplications(code) {
    const duplications = [];
    const lines = code.split('\n');
    const minLength = 3; // æœ€å°é‡è¤‡è¡Œæ•°

    for (let i = 0; i < lines.length - minLength; i++) {
      for (let j = i + minLength; j < lines.length - minLength; j++) {
        let matchLength = 0;
        while (matchLength < minLength &&
               lines[i + matchLength] === lines[j + matchLength]) {
          matchLength++;
        }

        if (matchLength >= minLength) {
          duplications.push({
            start1: i + 1,
            start2: j + 1,
            length: matchLength,
            content: lines.slice(i, i + matchLength).join('\n')
          });
        }
      }
    }

    return duplications;
  }

  // ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ¡ãƒ«ã®æ¤œå‡º
  detectCodeSmells(code) {
    const smells = [];
    const lines = code.split('\n');

    // é•·ã„ãƒ¡ã‚½ãƒƒãƒ‰
    const functions = this.extractFunctions(code);
    functions.forEach(func => {
      if (func.lines > 50) {
        smells.push({
          type: 'Long Method',
          line: func.startLine,
          message: `ãƒ¡ã‚½ãƒƒãƒ‰ãŒé•·ã™ãã¾ã™ (${func.lines}è¡Œ)`
        });
      }
    });

    // å¤šãã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    functions.forEach(func => {
      if (func.parameters > 5) {
        smells.push({
          type: 'Long Parameter List',
          line: func.startLine,
          message: `ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¤šã™ãã¾ã™ (${func.parameters}å€‹)`
        });
      }
    });

    // é‡è¤‡ã‚³ãƒ¼ãƒ‰
    const duplications = this.findDuplications(code);
    duplications.forEach(dup => {
      smells.push({
        type: 'Duplicated Code',
        line: dup.start1,
        message: `${dup.length}è¡Œã®é‡è¤‡ã‚³ãƒ¼ãƒ‰ã‚’æ¤œå‡º`
      });
    });

    return smells;
  }

  // ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ææ¡ˆã®ç”Ÿæˆ
  async generateRefactoringSuggestions(analysis) {
    const suggestions = [];

    // è¤‡é›‘æ€§ã«åŸºã¥ãææ¡ˆ
    if (analysis.complexity > 10) {
      suggestions.push({
        type: 'Extract Method',
        priority: 'high',
        description: 'è¤‡é›‘ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’å°ã•ãªãƒ¡ã‚½ãƒƒãƒ‰ã«åˆ†å‰²',
        estimatedBenefit: 'å¯èª­æ€§ã¨ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã®å‘ä¸Š'
      });
    }

    // ä¿å®ˆæ€§ã«åŸºã¥ãææ¡ˆ
    if (analysis.maintainability < 70) {
      suggestions.push({
        type: 'Rename Method/Variable',
        priority: 'medium',
        description: 'ã‚ã‹ã‚Šã‚„ã™ã„åå‰ã«å¤‰æ›´',
        estimatedBenefit: 'ã‚³ãƒ¼ãƒ‰ã®ç†è§£å®¹æ˜“æ€§ã®å‘ä¸Š'
      });
    }

    // é‡è¤‡ã‚³ãƒ¼ãƒ‰ã«åŸºã¥ãææ¡ˆ
    if (analysis.duplications.length > 0) {
      suggestions.push({
        type: 'Extract Method',
        priority: 'high',
        description: 'é‡è¤‡ã‚³ãƒ¼ãƒ‰ã‚’å…±é€šãƒ¡ã‚½ãƒƒãƒ‰ã«æŠ½å‡º',
        estimatedBenefit: 'ä¿å®ˆæ€§ã®å‘ä¸Šã¨ãƒã‚°å‰Šæ¸›'
      });
    }

    // Claude Codeã«ã‚ˆã‚‹è¿½åŠ ææ¡ˆ
    const claudeSuggestions = await this.getClaudeRefactoringSuggestions(analysis);
    suggestions.push(...claudeSuggestions);

    return suggestions;
  }

  // Claude Codeã«ã‚ˆã‚‹ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ææ¡ˆ
  async getClaudeRefactoringSuggestions(analysis) {
    const prompt = `
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰åˆ†æçµæœã«åŸºã¥ã„ã¦ã€ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ææ¡ˆã‚’ã—ã¦ãã ã•ã„:

è¤‡é›‘æ€§: ${analysis.complexity}
ä¿å®ˆæ€§: ${analysis.maintainability}
ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§: ${analysis.testability}
é‡è¤‡ã‚³ãƒ¼ãƒ‰: ${analysis.duplications.length}ä»¶
ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ¡ãƒ«: ${analysis.smells.length}ä»¶

ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ¡ãƒ«ã®è©³ç´°:
${analysis.smells.map(s => `- ${s.type}: ${s.message}`).join('\n')}

ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®è¦³ç‚¹:
1. è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã®é©ç”¨
2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æœ€é©åŒ–
3. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®å‘ä¸Š
4. ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§ã®æ”¹å–„
5. ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã®å‘ä¸Š

å„ªå…ˆåº¦ (high/medium/low) ã¨æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœã‚’å«ã‚ã¦ææ¡ˆã—ã¦ãã ã•ã„ã€‚
`;

    // å®Ÿéš›ã®Claude Code APIå‘¼ã³å‡ºã—ï¼ˆãƒ¢ãƒƒã‚¯ï¼‰
    return [
      {
        type: 'Apply Strategy Pattern',
        priority: 'medium',
        description: 'æ¡ä»¶åˆ†å²ã‚’ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç½®æ›',
        estimatedBenefit: 'æ‹¡å¼µæ€§ã¨ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã®å‘ä¸Š'
      }
    ];
  }

  // ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®é©ç”¨
  async applyRefactoring(code, refactoring) {
    // å®Ÿéš›ã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å‡¦ç†ã‚’å®Ÿè£…
    // ã“ã“ã§ã¯ãƒ¢ãƒƒã‚¯å®Ÿè£…
    return {
      success: true,
      code: code, // å®Ÿéš›ã«ã¯å¤‰æ›å¾Œã®ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™
      changes: [`Applied ${refactoring.type}`]
    };
  }

  // æ™‚é–“è¦‹ç©ã‚‚ã‚Š
  estimateTime(refactorings) {
    return refactorings.reduce((sum, r) => {
      switch (r.priority) {
        case 'high': return sum + 30; // 30åˆ†
        case 'medium': return sum + 15; // 15åˆ†
        case 'low': return sum + 5; // 5åˆ†
        default: return sum;
      }
    }, 0);
  }

  // é–¢æ•°ã®æŠ½å‡º
  extractFunctions(code) {
    // ç°¡æ˜“çš„ãªé–¢æ•°æŠ½å‡ºï¼ˆå®Ÿéš›ã«ã¯è¨€èªã«å¿œã˜ãŸãƒ‘ãƒ¼ã‚µãƒ¼ã‚’ä½¿ç”¨ï¼‰
    const functions = [];
    const lines = code.split('\n');
    let inFunction = false;
    let currentFunction = null;
    let braceCount = 0;

    lines.forEach((line, index) => {
      if (line.match(/\bfunction\s+\w+\s*\(|class\s+\w+\s*\{|=>\s*\{/)) {
        inFunction = true;
        currentFunction = {
          name: line.match(/\b(function\s+\w+|class\s+\w+|\w+)\s*[\(\{]/)?.[1] || 'anonymous',
          startLine: index + 1,
          lines: 0,
          parameters: 0,
          responsibilities: 1
        };
        braceCount = (line.match(/\{/g) || []).length;
      }

      if (inFunction) {
        currentFunction.lines++;
        braceCount += (line.match(/\{/g) || []).length;
        braceCount -= (line.match(/\}/g) || []).length;

        if (braceCount === 0) {
          functions.push(currentFunction);
          inFunction = false;
          currentFunction = null;
        }
      }
    });

    return functions;
  }

  // æ§‹æ–‡ãƒã‚§ãƒƒã‚¯
  checkSyntax(code) {
    // å®Ÿéš›ã®è¨€èªã«å¿œã˜ãŸæ§‹æ–‡ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè£…
    return [];
  }

  // æ„å‘³çš„ãªç­‰ä¾¡æ€§ãƒã‚§ãƒƒã‚¯
  checkSemanticEquivalence(original, refactored) {
    // å®Ÿéš›ã®ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯åˆ†æã‚’å®Ÿè£…
    return { issues: [] };
  }

  // ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
  runTests(code, tests) {
    // å®Ÿéš›ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚’å®Ÿè£…
    return { passed: true, failures: [] };
  }

  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å½±éŸ¿ã®è©•ä¾¡
  assessPerformanceImpact(original, refactored) {
    // å®Ÿéš›ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æã‚’å®Ÿè£…
    return { impact: 'neutral', change: 0 };
  }

  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®è¨ˆç®—
  calculateMetrics(code) {
    return {
      complexity: this.calculateComplexity(code),
      maintainability: this.calculateMaintainability(code),
      testability: this.calculateTestability(code),
      duplications: this.findDuplications(code).length
    };
  }
}

module.exports = { RefactoringAssistant };
```

2. ä½¿ç”¨ä¾‹

`examples/refactoring-example.js`ã‚’ä½œæˆã—ã¾ã™ã€‚

_examples/refactoring-example.js_

```javascript
const { RefactoringAssistant } = require('../src/refactoring-assistant');

// ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®åˆæœŸåŒ–
const assistant = new RefactoringAssistant();

async function demonstrateRefactoring() {
  console.log('ğŸ”§ ã‚³ãƒ¼ãƒ‰ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®ãƒ‡ãƒ¢');
  console.log('=' .repeat(60));

  try {
    // 1. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¯¾è±¡ã®ã‚³ãƒ¼ãƒ‰
    console.log('\n1. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¯¾è±¡ã®ã‚³ãƒ¼ãƒ‰');
    const originalCode = `
class OrderProcessor {
  constructor() {
    this.orders = [];
    this.customers = [];
    this.products = [];
  }

  processOrder(orderData) {
    // é¡§å®¢æƒ…å ±ã®æ¤œè¨¼
    if (!orderData.customerId || !orderData.items || orderData.items.length === 0) {
      throw new Error('Invalid order data');
    }

    // é¡§å®¢ã®å–å¾—
    const customer = this.customers.find(c => c.id === orderData.customerId);
    if (!customer) {
      throw new Error('Customer not found');
    }

    // åœ¨åº«ãƒã‚§ãƒƒã‚¯ã¨åˆè¨ˆé‡‘é¡ã®è¨ˆç®—
    let totalAmount = 0;
    for (const item of orderData.items) {
      const product = this.products.find(p => p.id === item.productId);
      if (!product) {
        throw new Error(\`Product \${item.productId} not found\`);
      }
      if (product.stock < item.quantity) {
        throw new Error(\`Insufficient stock for product \${item.productId}\`);
      }
      totalAmount += product.price * item.quantity;
    }

    // æ³¨æ–‡ã®ä½œæˆ
    const order = {
      id: Date.now(),
      customerId: orderData.customerId,
      items: orderData.items,
      totalAmount: totalAmount,
      status: 'pending',
      createdAt: new Date()
    };

    // åœ¨åº«ã®æ›´æ–°
    for (const item of order.items) {
      const product = this.products.find(p => p.id === item.productId);
      product.stock -= item.quantity;
    }

    // æ³¨æ–‡ã®ä¿å­˜
    this.orders.push(order);

    // é¡§å®¢ã®é€šçŸ¥
    if (customer.email) {
      this.sendEmail(customer.email, 'Order Confirmation', \`Your order \${order.id} has been received\`);
    }

    return order;
  }

  sendEmail(to, subject, body) {
    // ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã®å®Ÿè£…
    console.log(\`Email sent to \${to}: \${subject}\`);
  }
}
`;

    console.log('ğŸ“ å…ƒã®ã‚³ãƒ¼ãƒ‰:');
    console.log(originalCode);

    // 2. ã‚³ãƒ¼ãƒ‰åˆ†æ
    console.log('\n2. ã‚³ãƒ¼ãƒ‰åˆ†æ');
    const analysis = await assistant.analyzeCode(originalCode);
    console.log('ğŸ“Š åˆ†æçµæœ:');
    console.log(`  è¤‡é›‘æ€§: ${analysis.complexity}`);
    console.log(`  ä¿å®ˆæ€§: ${analysis.maintainability}`);
    console.log(`  ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§: ${analysis.testability}`);
    console.log(`  é‡è¤‡ã‚³ãƒ¼ãƒ‰: ${analysis.duplications.length}ä»¶`);
    console.log(`  ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ¡ãƒ«: ${analysis.smells.length}ä»¶`);

    // 3. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ææ¡ˆ
    console.log('\n3. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ææ¡ˆ');
    console.log('ğŸ’¡ ææ¡ˆå†…å®¹:');
    analysis.suggestions.forEach((suggestion, index) => {
      console.log(`  ${index + 1}. ${suggestion.type} (${suggestion.priority})`);
      console.log(`     èª¬æ˜: ${suggestion.description}`);
      console.log(`     åŠ¹æœ: ${suggestion.estimatedBenefit}`);
      console.log();
    });

    // 4. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°è¨ˆç”»ã®ä½œæˆ
    console.log('4. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°è¨ˆç”»');
    const plan = assistant.createRefactoringPlan(analysis);
    console.log('ğŸ“‹ ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°è¨ˆç”»:');
    plan.phases.forEach((phase, index) => {
      console.log(`  ãƒ•ã‚§ãƒ¼ã‚º${index + 1}: ${phase.name}`);
      console.log(`    è¦‹ç©ã‚‚ã‚Šæ™‚é–“: ${phase.estimatedTime}åˆ†`);
      console.log(`    èª¬æ˜: ${phase.description}`);
      console.log(`    ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ•°: ${phase.refactorings.length}`);
      console.log();
    });

    // 5. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®å®Ÿè¡Œ
    console.log('5. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®å®Ÿè¡Œ');
    const refactorings = analysis.suggestions.slice(0, 3); // ä¸Šä½3ã¤ã‚’å®Ÿè¡Œ
    const result = await assistant.performRefactoring(originalCode, refactorings);

    console.log('âœ… ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å®Œäº†');
    console.log(`é©ç”¨ã—ãŸãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°: ${result.appliedRefactorings.length}ä»¶`);
    console.log('ğŸ“ˆ æ”¹å–„å¾Œã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹:');
    console.log(`  è¤‡é›‘æ€§: ${result.metrics.complexity}`);
    console.log(`  ä¿å®ˆæ€§: ${result.metrics.maintainability}`);
    console.log(`  ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§: ${result.metrics.testability}`);

    // 6. å®‰å…¨æ€§ã®æ¤œè¨¼
    console.log('\n6. å®‰å…¨æ€§ã®æ¤œè¨¼');
    const validation = assistant.validateRefactoring(
      originalCode,
      result.code,
      null // ãƒ†ã‚¹ãƒˆã¯çœç•¥
    );

    if (validation.isSafe) {
      console.log('âœ… ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã¯å®‰å…¨ã§ã™');
    } else {
      console.log('âš ï¸  ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã«å•é¡ŒãŒã‚ã‚Šã¾ã™:');
      validation.issues.forEach(issue => {
        console.log(`  - ${issue.type}: ${issue.message}`);
      });
    }

    // 7. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¾Œã®ã‚³ãƒ¼ãƒ‰
    console.log('\n7. ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¾Œã®ã‚³ãƒ¼ãƒ‰');
    console.log('ğŸ”§ æ”¹å–„å¾Œã®ã‚³ãƒ¼ãƒ‰:');
    console.log(result.code);

    console.log('\nğŸ‰ ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ãƒ‡ãƒ¢ãŒå®Œäº†ã—ã¾ã—ãŸï¼');

  } catch (error) {
    console.error('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error.message);
  }
}

// ãƒ‡ãƒ¢ã®å®Ÿè¡Œ
demonstrateRefactoring().catch(console.error);
```

:::

## ã¾ã¨ã‚

ã“ã®ãƒšãƒ¼ã‚¸ã§ã¯ã€Claude Codeã‚’æ´»ç”¨ã—ãŸå®Ÿè·µçš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«ã¤ã„ã¦å­¦ã³ã¾ã—ãŸã€‚ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒé–‹ç™ºã€ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã€ã‚³ãƒ¼ãƒ‰ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ãªã©ã®æ‰‹æ³•ã‚’é©åˆ‡ã«çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ãƒãƒ¼ãƒ ã®ç”Ÿç”£æ€§ã¨ã‚³ãƒ¼ãƒ‰å“è³ªã‚’å¤§å¹…ã«å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

:::note è¦ç‚¹ã®ã¾ã¨ã‚

- ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒé–‹ç™ºã¯Gitã‚’ä½¿ã£ãŸåŠ¹æœçš„ãªãƒ–ãƒ©ãƒ³ãƒç®¡ç†æ‰‹æ³•
- ãƒšã‚¢ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã¯çŸ¥è­˜å…±æœ‰ã¨å“è³ªå‘ä¸Šã«åŠ¹æœçš„
- ã‚³ãƒ¼ãƒ‰ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã¯ä¿å®ˆæ€§ã¨æ‹¡å¼µæ€§ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã«é‡è¦
- Claude Codeã‚’æ´»ç”¨ã—ãŸè‡ªå‹•åŒ–ãƒ„ãƒ¼ãƒ«ã§ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’æœ€é©åŒ–
- å„æ‰‹æ³•ã«ã¯é©åˆ‡ãªå ´é¢ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ãŒå­˜åœ¨
- å“è³ªãƒã‚§ãƒƒã‚¯ã¨å®‰å…¨æ€§æ¤œè¨¼ã¯ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®æˆåŠŸã«ä¸å¯æ¬ 

:::

## é–¢é€£è¨˜äº‹

[ãƒãƒ¼ãƒ é–‹ç™ºã®åŸºç¤](../team-development-basics/team-development-basics.md)
[ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã¨Git](../version-control/version-control.md)
[ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„](../coding-standards/coding-standards.md)
[ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†](../project-management/project-management.md)