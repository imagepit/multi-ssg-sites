---
title: "é«˜åº¦ãªæŠ€è¡“"
description: "Claude Codeã‚’æ´»ç”¨ã—ãŸãƒãƒ¼ãƒ é–‹ç™ºã«ãŠã‘ã‚‹é«˜åº¦ãªæŠ€è¡“ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’å­¦ã³ã¾ã™ã€‚ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã€CI/CDã€DevOpsã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãªã©ã®å®Ÿè·µçš„ãªæ‰‹æ³•ã‚’ãƒã‚¹ã‚¿ãƒ¼ã—ã¾ã™ã€‚"
status: "published"
priority: "high"
tags: ["é«˜åº¦ãªæŠ€è¡“", "ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹", "CI/CD", "DevOps", "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£"]
author: "Claude"
category: "team-development"
---

# é«˜åº¦ãªæŠ€è¡“

Claude Codeã‚’æ´»ç”¨ã—ãŸãƒãƒ¼ãƒ é–‹ç™ºã«ãŠã‘ã‚‹é«˜åº¦ãªæŠ€è¡“ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«ã¤ã„ã¦å­¦ã³ã¾ã™ã€‚ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ç¾ä»£ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢é–‹ç™ºã§å¿…é ˆã¨ãªã‚‹ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã€DevOpsãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ãªã©ã®å®Ÿè·µçš„ãªæ‰‹æ³•ã‚’è§£èª¬ã—ã¾ã™ã€‚

## é«˜åº¦ãªæŠ€è¡“ã®é‡è¦æ€§

ç¾ä»£ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢é–‹ç™ºã§ã¯ã€åŸºæœ¬çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚¹ã‚­ãƒ«ã ã‘ã§ãªãã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã€è‡ªå‹•åŒ–ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãªã©ã®é«˜åº¦ãªæŠ€è¡“ãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚Claude Codeã‚’é©åˆ‡ã«æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€ã“ã‚Œã‚‰ã®è¤‡é›‘ãªæŠ€è¡“ã‚’åŠ¹ç‡çš„ã«ç¿’å¾—ã—é©ç”¨ã§ãã¾ã™ã€‚

:::note é«˜åº¦ãªæŠ€è¡“ãŒå¿…è¦ãªç†ç”±

- **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£**: å¤§è¦æ¨¡ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åŠ¹ç‡çš„ã«æ§‹ç¯‰ãƒ»é‹ç”¨
- **ä¿¡é ¼æ€§**: é«˜å¯ç”¨æ€§ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆãƒˆãƒ¬ãƒ©ãƒ³ã‚¹ã®ç¢ºä¿
- **é–‹ç™ºåŠ¹ç‡**: è‡ªå‹•åŒ–ã«ã‚ˆã‚‹é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã®æœ€é©åŒ–
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: ç¾ä»£ã®è„…å¨ã«å¯¾ã™ã‚‹å …ç‰¢ãªé˜²å¾¡
- **ä¿å®ˆæ€§**: é•·æœŸçš„ãªé‹ç”¨ã¨é€²åŒ–ã«å¯¾å¿œã™ã‚‹è¨­è¨ˆ

:::

## ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å°ã•ãªç‹¬ç«‹ã—ãŸã‚µãƒ¼ãƒ“ã‚¹ã®é›†åˆã¨ã—ã¦æ§‹ç¯‰ã™ã‚‹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚¹ã‚¿ã‚¤ãƒ«ã§ã™ã€‚

:::step

1. ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ç’°å¢ƒã®æ§‹ç¯‰

ä»»æ„ã®å ´æ‰€ï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ãªã©ï¼‰ã§`microservices-practice`ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆã—ã€å®Ÿè·µã‚’å§‹ã‚ã¾ã™ã€‚

```bash
mkdir microservices-practice
cd microservices-practice
npm init -y
```

2. ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®å®Ÿè£…

`src/microservices-framework.js`ã‚’ä½œæˆã—ã€Claude Codeã‚’æ´»ç”¨ã—ãŸãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–‹ç™ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

_src/microservices-framework.js_

```javascript
/**
 * Claude Codeã‚’æ´»ç”¨ã—ãŸãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–‹ç™ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
 * ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡ã€è¨­å®šç®¡ç†ã€ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãªã©ã®æ©Ÿèƒ½ã‚’æä¾›
 */
const express = require('express');
const axios = require('axios');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

class MicroservicesFramework {
  constructor(config = {}) {
    this.services = new Map();
    this.config = {
      port: config.port || 3000,
      serviceName: config.serviceName || 'microservice',
      registryUrl: config.registryUrl || 'http://localhost:8000',
      healthCheckInterval: config.healthCheckInterval || 30000,
      ...config
    };
    this.app = express();
    this.middleware = [];
    this.circuitBreakers = new Map();
    this.serviceDiscovery = new ServiceDiscovery(this.config.registryUrl);
    this.loadBalancer = new LoadBalancer();
    this.monitoring = new MonitoringService();

    this.setupMiddleware();
    this.setupHealthChecks();
  }

  // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®è¨­å®š
  setupMiddleware() {
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
    this.app.use(helmet());
    this.app.use(cors({
      origin: this.config.allowedOrigins || ['http://localhost:3000'],
      credentials: true
    }));

    // ãƒ¬ãƒ¼ãƒˆåˆ¶é™
    const limiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15åˆ†
      max: 100 // å„IPã‚ãŸã‚Š100ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
    });
    this.app.use(limiter);

    // JSONãƒ‘ãƒ¼ã‚µãƒ¼
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true }));

    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ­ã‚®ãƒ³ã‚°
    this.app.use(this.requestLogger.bind(this));

    // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    this.app.use(this.errorHandler.bind(this));
  }

  // ã‚µãƒ¼ãƒ“ã‚¹ã®ç™»éŒ²
  async registerService(serviceInfo) {
    const service = {
      id: this.generateId(),
      name: this.config.serviceName,
      host: serviceInfo.host || 'localhost',
      port: serviceInfo.port || this.config.port,
      health: '/health',
      metadata: serviceInfo.metadata || {},
      registeredAt: new Date(),
      status: 'healthy'
    };

    await this.serviceDiscovery.register(service);
    this.services.set(service.id, service);

    console.log(`âœ… ã‚µãƒ¼ãƒ“ã‚¹ã‚’ç™»éŒ²ã—ã¾ã—ãŸ: ${service.name} (${service.host}:${service.port})`);

    // è‡ªå‹•ç™»éŒ²è§£é™¤ã®è¨­å®š
    process.on('SIGTERM', () => this.deregisterService(service.id));
    process.on('SIGINT', () => this.deregisterService(service.id));

    return service;
  }

  // ã‚µãƒ¼ãƒ“ã‚¹ã®ç™»éŒ²è§£é™¤
  async deregisterService(serviceId) {
    const service = this.services.get(serviceId);
    if (service) {
      await this.serviceDiscovery.deregister(serviceId);
      this.services.delete(serviceId);
      console.log(`âŒ ã‚µãƒ¼ãƒ“ã‚¹ã®ç™»éŒ²ã‚’è§£é™¤ã—ã¾ã—ãŸ: ${service.name}`);
    }
  }

  // APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ä½œæˆ
  createEndpoint(path, handler, options = {}) {
    const method = options.method || 'get';
    const middleware = options.middleware || [];
    const rateLimit = options.rateLimit;
    const auth = options.auth;

    // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®é©ç”¨
    const applyMiddleware = (req, res, next) => {
      // ãƒ¬ãƒ¼ãƒˆåˆ¶é™
      if (rateLimit) {
        const limiter = rateLimit({
          windowMs: rateLimit.windowMs || 15 * 60 * 1000,
          max: rateLimit.max || 100,
          message: rateLimit.message || 'Too many requests'
        });
        limiter(req, res, next);
      } else {
        next();
      }
    };

    // èªè¨¼
    const applyAuth = async (req, res, next) => {
      if (auth) {
        try {
          await this.authenticate(req, auth);
          next();
        } catch (error) {
          res.status(401).json({ error: 'Unauthorized', message: error.message });
        }
      } else {
        next();
      }
    };

    // ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ç™»éŒ²
    this.app[method](path, applyMiddleware, applyAuth, ...middleware, async (req, res) => {
      try {
        const startTime = Date.now();

        // ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã®ãƒã‚§ãƒƒã‚¯
        const circuitBreaker = this.circuitBreakers.get(path);
        if (circuitBreaker && !circuitBreaker.allowRequest()) {
          throw new Error('Service temporarily unavailable');
        }

        // ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®å®Ÿè¡Œ
        const result = await handler(req, res);

        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ ã®è¨˜éŒ²
        const responseTime = Date.now() - startTime;
        this.monitoring.recordMetric('response_time', responseTime, { endpoint: path });

        res.json(result);
      } catch (error) {
        this.handleEndpointError(error, req, res, path);
      }
    });

    console.log(`ğŸ“¡ ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ: ${method.toUpperCase()} ${path}`);
  }

  // ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡
  async callService(serviceName, endpoint, options = {}) {
    const service = await this.serviceDiscovery.discover(serviceName);
    if (!service) {
      throw new Error(`Service ${serviceName} not found`);
    }

    // ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°
    const targetService = this.loadBalancer.select(service);

    // ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã®å–å¾—ã¾ãŸã¯ä½œæˆ
    let circuitBreaker = this.circuitBreakers.get(`${serviceName}${endpoint}`);
    if (!circuitBreaker) {
      circuitBreaker = new CircuitBreaker({
        timeout: options.timeout || 5000,
        errorThreshold: options.errorThreshold || 0.5,
        resetTimeout: options.resetTimeout || 30000
      });
      this.circuitBreakers.set(`${serviceName}${endpoint}`, circuitBreaker);
    }

    return circuitBreaker.execute(async () => {
      const url = `${targetService.protocol || 'http'}://${targetService.host}:${targetService.port}${endpoint}`;

      const requestConfig = {
        method: options.method || 'get',
        url,
        headers: {
          'Content-Type': 'application/json',
          'X-Service-Name': this.config.serviceName,
          'X-Request-ID': this.generateRequestId(),
          ...options.headers
        },
        timeout: options.timeout || 5000,
        data: options.data
      };

      // ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯
      const maxRetries = options.retries || 2;
      let lastError;

      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const response = await axios(requestConfig);

          // æˆåŠŸãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®è¨˜éŒ²
          this.monitoring.recordMetric('service_call_success', 1, {
            service: serviceName,
            endpoint,
            attempt
          });

          return response.data;
        } catch (error) {
          lastError = error;

          // å¤±æ•—ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®è¨˜éŒ²
          this.monitoring.recordMetric('service_call_error', 1, {
            service: serviceName,
            endpoint,
            attempt,
            error: error.code || 'unknown'
          });

          if (attempt === maxRetries) {
            throw error;
          }

          // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }

      throw lastError;
    });
  }

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼ã®çµ±åˆ
  setupMessageQueue(config = {}) {
    const messageQueue = new MessageQueue(config);

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®ç™»éŒ²
    this.onMessage = (topic, handler) => {
      messageQueue.subscribe(topic, handler);
    };

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡
    this.publishMessage = (topic, message) => {
      return messageQueue.publish(topic, message);
    };

    console.log('ğŸ“¨ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼ã‚’è¨­å®šã—ã¾ã—ãŸ');
    return messageQueue;
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã®è¨­å®š
  setupDatabase(config) {
    const database = new DatabaseConnection(config);

    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    this.withTransaction = async (callback) => {
      return database.transaction(callback);
    };

    // ã‚¯ã‚¨ãƒªãƒ“ãƒ«ãƒ€ãƒ¼
    this.query = (sql, params) => {
      return database.query(sql, params);
    };

    console.log('ğŸ—„ï¸  ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚’è¨­å®šã—ã¾ã—ãŸ');
    return database;
  }

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®è¨­å®š
  setupCache(config) {
    const cache = new CacheService(config);

    this.cache = {
      get: (key) => cache.get(key),
      set: (key, value, ttl) => cache.set(key, value, ttl),
      delete: (key) => cache.delete(key),
      clear: () => cache.clear()
    };

    console.log('ğŸ’¾ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µãƒ¼ãƒ“ã‚¹ã‚’è¨­å®šã—ã¾ã—ãŸ');
    return cache;
  }

  // èªè¨¼ã¨èªå¯
  async authenticate(req, authConfig) {
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (!token) {
      throw new Error('Authorization token required');
    }

    // JWTã®æ¤œè¨¼
    if (authConfig.type === 'jwt') {
      return this.verifyJWT(token, authConfig.secret);
    }

    // APIã‚­ãƒ¼ã®æ¤œè¨¼
    if (authConfig.type === 'api_key') {
      return this.verifyAPIKey(token, authConfig.keys);
    }

    throw new Error('Unsupported authentication type');
  }

  // JWTã®æ¤œè¨¼
  async verifyJWT(token, secret) {
    const jwt = require('jsonwebtoken');

    try {
      const decoded = jwt.verify(token, secret);
      return decoded;
    } catch (error) {
      throw new Error('Invalid JWT token');
    }
  }

  // APIã‚­ãƒ¼ã®æ¤œè¨¼
  async verifyAPIKey(token, validKeys) {
    if (!validKeys.includes(token)) {
      throw new Error('Invalid API key');
    }

    return { type: 'api_key', key: token };
  }

  // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã®è¨­å®š
  setupHealthChecks() {
    this.app.get('/health', async (req, res) => {
      const health = {
        status: 'healthy',
        timestamp: new Date(),
        service: this.config.serviceName,
        version: this.config.version || '1.0.0',
        checks: {}
      };

      try {
        // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒã‚§ãƒƒã‚¯
        if (this.database) {
          health.checks.database = await this.checkDatabase();
        }

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
        if (this.cache) {
          health.checks.cache = await this.checkCache();
        }

        // å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹æ¥ç¶šãƒã‚§ãƒƒã‚¯
        for (const [serviceName, service] of this.services) {
          health.checks[serviceName] = await this.checkService(service);
        }

        // å…¨ä½“ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¤å®š
        const hasFailures = Object.values(health.checks).some(check => check.status !== 'healthy');
        health.status = hasFailures ? 'unhealthy' : 'healthy';

        res.status(health.status === 'healthy' ? 200 : 503).json(health);
      } catch (error) {
        health.status = 'unhealthy';
        health.error = error.message;
        res.status(503).json(health);
      }
    });
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  async checkDatabase() {
    try {
      await this.database.query('SELECT 1');
      return { status: 'healthy', responseTime: Date.now() - this.dbCheckStart };
    } catch (error) {
      return { status: 'unhealthy', error: error.message };
    }
  }

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  async checkCache() {
    try {
      const testKey = 'health_check';
      await this.cache.set(testKey, 'ok', 5);
      const value = await this.cache.get(testKey);
      await this.cache.delete(testKey);

      return value === 'ok'
        ? { status: 'healthy' }
        : { status: 'unhealthy', error: 'Cache read/write failed' };
    } catch (error) {
      return { status: 'unhealthy', error: error.message };
    }
  }

  // ã‚µãƒ¼ãƒ“ã‚¹ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  async checkService(service) {
    try {
      const response = await axios.get(
        `http://${service.host}:${service.port}/health`,
        { timeout: 5000 }
      );

      return {
        status: response.data.status === 'healthy' ? 'healthy' : 'unhealthy',
        responseTime: response.headers['x-response-time']
      };
    } catch (error) {
      return { status: 'unhealthy', error: error.message };
    }
  }

  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®åé›†
  collectMetrics() {
    return this.monitoring.getMetrics();
  }

  // ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•
  async start() {
    try {
      // ã‚µãƒ¼ãƒ“ã‚¹ã®ç™»éŒ²
      await this.registerService({
        host: this.config.host || 'localhost',
        port: this.config.port,
        metadata: {
          version: this.config.version || '1.0.0',
          environment: this.config.environment || 'development'
        }
      });

      // ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•
      const server = this.app.listen(this.config.port, () => {
        console.log(`ğŸš€ ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã¾ã—ãŸ: ${this.config.serviceName} on port ${this.config.port}`);
      });

      // ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³
      this.setupGracefulShutdown(server);

      return server;
    } catch (error) {
      console.error('âŒ ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      throw error;
    }
  }

  // ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ­ã‚¬ãƒ¼
  requestLogger(req, res, next) {
    const start = Date.now();
    const requestId = this.generateRequestId();

    req.requestId = requestId;
    req.startTime = start;

    res.on('finish', () => {
      const responseTime = Date.now() - start;

      this.monitoring.recordMetric('http_requests', 1, {
        method: req.method,
        path: req.path,
        status: res.statusCode,
        responseTime
      });

      console.log(`[${requestId}] ${req.method} ${req.path} - ${res.statusCode} (${responseTime}ms)`);
    });

    next();
  }

  // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  errorHandler(error, req, res, next) {
    console.error(`[${req.requestId}] Error:`, error);

    this.monitoring.recordMetric('errors', 1, {
      type: error.name,
      path: req.path,
      method: req.method
    });

    res.status(error.status || 500).json({
      error: error.name || 'Internal Server Error',
      message: error.message || 'An unexpected error occurred',
      requestId: req.requestId
    });
  }

  // ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  handleEndpointError(error, req, res, endpoint) {
    const circuitBreaker = this.circuitBreakers.get(endpoint);
    if (circuitBreaker) {
      circuitBreaker.recordFailure();
    }

    this.monitoring.recordMetric('endpoint_errors', 1, {
      endpoint,
      error: error.name
    });

    if (error.response) {
      res.status(error.response.status).json({
        error: 'Service Error',
        message: error.response.data.message || 'External service error'
      });
    } else if (error.code === 'ECONNABORTED') {
      res.status(504).json({
        error: 'Timeout',
        message: 'Service timeout'
      });
    } else {
      res.status(500).json({
        error: 'Internal Server Error',
        message: error.message
      });
    }
  }

  // ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã®è¨­å®š
  setupGracefulShutdown(server) {
    const shutdown = async (signal) => {
      console.log(`\nğŸ›‘ ${signal}ã‚’å—ä¿¡ã€ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã‚’é–‹å§‹ã—ã¾ã™...`);

      // æ–°ã—ã„æ¥ç¶šã®å—ã‘ä»˜ã‘ã‚’åœæ­¢
      server.close(() => {
        console.log('âœ… ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã—ã¾ã—ãŸ');
        process.exit(0);
      });

      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå¾Œã«å¼·åˆ¶çµ‚äº†
      setTimeout(() => {
        console.error('âŒ ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚å¼·åˆ¶çµ‚äº†ã—ã¾ã™ã€‚');
        process.exit(1);
      }, 10000);
    };

    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGINT', () => shutdown('SIGINT'));
  }

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }

  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ã‚µãƒ¼ãƒ“ã‚¹ãƒ‡ã‚£ã‚¹ã‚«ãƒãƒªãƒ¼
class ServiceDiscovery {
  constructor(registryUrl) {
    this.registryUrl = registryUrl;
    this.services = new Map();
    this.cache = new Map();
    this.cacheTTL = 30000; // 30ç§’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
  }

  async register(service) {
    try {
      await axios.post(`${this.registryUrl}/register`, service);
      console.log(`âœ… ã‚µãƒ¼ãƒ“ã‚¹ã‚’ç™»éŒ²ã—ã¾ã—ãŸ: ${service.name}`);
    } catch (error) {
      console.error('âŒ ã‚µãƒ¼ãƒ“ã‚¹ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
    }
  }

  async deregister(serviceId) {
    try {
      await axios.delete(`${this.registryUrl}/deregister/${serviceId}`);
      console.log(`âœ… ã‚µãƒ¼ãƒ“ã‚¹ç™»éŒ²ã‚’è§£é™¤ã—ã¾ã—ãŸ: ${serviceId}`);
    } catch (error) {
      console.error('âŒ ã‚µãƒ¼ãƒ“ã‚¹ç™»éŒ²è§£é™¤ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
    }
  }

  async discover(serviceName) {
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
    const cached = this.cache.get(serviceName);
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      return cached.services;
    }

    try {
      const response = await axios.get(`${this.registryUrl}/discover/${serviceName}`);
      const services = response.data;

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
      this.cache.set(serviceName, {
        services,
        timestamp: Date.now()
      });

      return services;
    } catch (error) {
      console.error(`âŒ ã‚µãƒ¼ãƒ“ã‚¹ç™ºè¦‹ã«å¤±æ•—ã—ã¾ã—ãŸ: ${serviceName}`, error.message);
      return null;
    }
  }
}

// ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚µãƒ¼
class LoadBalancer {
  constructor(strategy = 'round-robin') {
    this.strategy = strategy;
    this.counters = new Map();
  }

  select(services) {
    if (!services || services.length === 0) {
      throw new Error('No services available');
    }

    switch (this.strategy) {
      case 'round-robin':
        return this.roundRobin(services);
      case 'least-connections':
        return this.leastConnections(services);
      case 'random':
        return this.random(services);
      default:
        return services[0];
    }
  }

  roundRobin(services) {
    const serviceName = services[0].name;
    const counter = this.counters.get(serviceName) || 0;
    const selected = services[counter % services.length];
    this.counters.set(serviceName, counter + 1);
    return selected;
  }

  leastConnections(services) {
    return services.reduce((min, service) =>
      service.connections < min.connections ? service : min
    );
  }

  random(services) {
    return services[Math.floor(Math.random() * services.length)];
  }
}

// ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼
class CircuitBreaker {
  constructor(config) {
    this.config = {
      timeout: config.timeout || 5000,
      errorThreshold: config.errorThreshold || 0.5,
      resetTimeout: config.resetTimeout || 30000,
      ...config
    };

    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failures = 0;
    this.lastFailureTime = null;
    this.nextAttemptTime = null;
  }

  async execute(fn) {
    if (!this.allowRequest()) {
      throw new Error('Circuit breaker is OPEN');
    }

    try {
      const result = await fn();
      this.recordSuccess();
      return result;
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }

  allowRequest() {
    switch (this.state) {
      case 'CLOSED':
        return true;
      case 'OPEN':
        if (Date.now() >= this.nextAttemptTime) {
          this.state = 'HALF_OPEN';
          return true;
        }
        return false;
      case 'HALF_OPEN':
        return true;
      default:
        return true;
    }
  }

  recordSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }

  recordFailure() {
    this.failures++;
    this.lastFailureTime = Date.now();

    if (this.state === 'CLOSED' && this.failures >= this.config.errorThreshold * 10) {
      this.state = 'OPEN';
      this.nextAttemptTime = Date.now() + this.config.resetTimeout;
    } else if (this.state === 'HALF_OPEN') {
      this.state = 'OPEN';
      this.nextAttemptTime = Date.now() + this.config.resetTimeout;
    }
  }
}

// ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹
class MonitoringService {
  constructor() {
    this.metrics = new Map();
    this.alerts = [];
  }

  recordMetric(name, value, tags = {}) {
    const key = this.getMetricKey(name, tags);

    if (!this.metrics.has(key)) {
      this.metrics.set(key, {
        name,
        tags,
        values: [],
        timestamps: []
      });
    }

    const metric = this.metrics.get(key);
    metric.values.push(value);
    metric.timestamps.push(Date.now());

    // ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã®åˆ¶é™ï¼ˆæœ€æ–°1000ä»¶ï¼‰
    if (metric.values.length > 1000) {
      metric.values = metric.values.slice(-1000);
      metric.timestamps = metric.timestamps.slice(-1000);
    }

    // ã‚¢ãƒ©ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
    this.checkAlerts(name, value, tags);
  }

  getMetrics() {
    const summary = {};

    for (const [key, metric] of this.metrics) {
      const values = metric.values;
      if (values.length === 0) continue;

      summary[key] = {
        name: metric.name,
        tags: metric.tags,
        count: values.length,
        min: Math.min(...values),
        max: Math.max(...values),
        avg: values.reduce((sum, val) => sum + val, 0) / values.length,
        latest: values[values.length - 1]
      };
    }

    return summary;
  }

  getMetricKey(name, tags) {
    const tagString = Object.entries(tags)
      .map(([key, value]) => `${key}=${value}`)
      .join(',');
    return `${name}{${tagString}}`;
  }

  checkAlerts(name, value, tags) {
    // ã‚¢ãƒ©ãƒ¼ãƒˆãƒ«ãƒ¼ãƒ«ã®å®šç¾©ã¨ãƒã‚§ãƒƒã‚¯
    const alertRules = {
      'error_rate': { threshold: 5, operator: '>' },
      'response_time': { threshold: 1000, operator: '>' },
      'memory_usage': { threshold: 90, operator: '>' }
    };

    const rule = alertRules[name];
    if (rule) {
      const shouldAlert = rule.operator === '>' ? value > rule.threshold : value < rule.threshold;

      if (shouldAlert) {
        this.alerts.push({
          name,
          value,
          threshold: rule.threshold,
          tags,
          timestamp: Date.now()
        });
      }
    }
  }
}

// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
class MessageQueue {
  constructor(config) {
    this.config = config;
    this.subscribers = new Map();
    this.messages = [];
  }

  subscribe(topic, handler) {
    if (!this.subscribers.has(topic)) {
      this.subscribers.set(topic, []);
    }
    this.subscribers.get(topic).push(handler);
  }

  publish(topic, message) {
    this.messages.push({ topic, message, timestamp: Date.now() });

    const handlers = this.subscribers.get(topic) || [];
    handlers.forEach(handler => {
      try {
        handler(message);
      } catch (error) {
        console.error('Message handler error:', error);
      }
    });
  }
}

// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
class DatabaseConnection {
  constructor(config) {
    this.config = config;
    this.pool = [];
    this.maxConnections = config.maxConnections || 10;
  }

  async query(sql, params) {
    // å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    return { rows: [], fields: [] };
  }

  async transaction(callback) {
    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’å®Ÿè£…
    try {
      const result = await callback();
      return result;
    } catch (error) {
      throw error;
    }
  }
}

// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
class CacheService {
  constructor(config) {
    this.config = config;
    this.cache = new Map();
    this.defaultTTL = config.defaultTTL || 3600; // 1æ™‚é–“
  }

  async get(key) {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }

    return item.value;
  }

  async set(key, value, ttl = this.defaultTTL) {
    const expiry = Date.now() + (ttl * 1000);
    this.cache.set(key, { value, expiry });
  }

  async delete(key) {
    this.cache.delete(key);
  }

  async clear() {
    this.cache.clear();
  }
}

module.exports = { MicroservicesFramework };
```

:::

## CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Ÿè£…

ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨ç¶™ç¶šçš„ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã¯ã€ç¾ä»£ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢é–‹ç™ºã®åŸºç›¤ã§ã™ã€‚

:::step

1. CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Ÿè£…

`src/cicd-pipeline.js`ã‚’ä½œæˆã—ã€Claude Codeã‚’æ´»ç”¨ã—ãŸCI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

_src/cicd-pipeline.js_

```javascript
/**
 * Claude Codeã‚’æ´»ç”¨ã—ãŸCI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
 * è‡ªå‹•ãƒ“ãƒ«ãƒ‰ã€ãƒ†ã‚¹ãƒˆã€ãƒ‡ãƒ—ãƒ­ã‚¤ã‚’å®Ÿç¾
 */
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const axios = require('axios');

class CICDPipeline {
  constructor(config = {}) {
    this.config = {
      projectName: config.projectName || 'my-project',
      repository: config.repository || {},
      buildScript: config.buildScript || 'npm run build',
      testScript: config.testScript || 'npm test',
      deployScript: config.deployScript || 'npm run deploy',
      environments: config.environments || ['staging', 'production'],
      notifications: config.notifications || [],
      qualityGates: config.qualityGates || {},
      ...config
    };

    this.stages = new Map();
    this.artifacts = new Map();
    this.buildHistory = [];
    this.qualityMetrics = new Map();

    this.initializeStages();
  }

  // ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®åˆæœŸåŒ–
  initializeStages() {
    // ãƒ“ãƒ«ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¸
    this.stages.set('build', {
      name: 'Build',
      description: 'ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ãƒ“ãƒ«ãƒ‰ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«',
      script: this.config.buildScript,
      timeout: 600000, // 10åˆ†
      required: true
    });

    // ãƒ†ã‚¹ãƒˆã‚¹ãƒ†ãƒ¼ã‚¸
    this.stages.set('test', {
      name: 'Test',
      description: 'è‡ªå‹•ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ',
      script: this.config.testScript,
      timeout: 1800000, // 30åˆ†
      required: true,
      parallel: true
    });

    // å“è³ªãƒã‚§ãƒƒã‚¯ã‚¹ãƒ†ãƒ¼ã‚¸
    this.stages.set('quality', {
      name: 'Quality Check',
      description: 'ã‚³ãƒ¼ãƒ‰å“è³ªã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãƒã‚§ãƒƒã‚¯',
      script: 'npm run quality-check',
      timeout: 900000, // 15åˆ†
      required: true
    });

    // ãƒ‡ãƒ—ãƒ­ã‚¤ã‚¹ãƒ†ãƒ¼ã‚¸
    this.stages.set('deploy', {
      name: 'Deploy',
      description: 'ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ‡ãƒ—ãƒ­ã‚¤',
      script: this.config.deployScript,
      timeout: 1800000, // 30åˆ†
      required: false,
      environment: 'staging'
    });

    console.log('ğŸ”§ CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ');
  }

  // ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å®Ÿè¡Œ
  async executePipeline(trigger = 'manual', options = {}) {
    const buildId = this.generateBuildId();
    const build = {
      id: buildId,
      trigger,
      status: 'running',
      startTime: new Date(),
      commit: options.commit || this.getCurrentCommit(),
      branch: options.branch || 'main',
      environment: options.environment || 'staging',
      stages: [],
      artifacts: [],
      qualityMetrics: {},
      notifications: []
    };

    console.log(`ğŸš€ ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™: ${buildId}`);
    console.log(`ãƒˆãƒªã‚¬ãƒ¼: ${trigger}`);
    console.log(`ãƒ–ãƒ©ãƒ³ãƒ: ${build.branch}`);
    console.log(`ç’°å¢ƒ: ${build.environment}`);

    try {
      // å‰å‡¦ç†
      await this.preBuild(build);

      // ã‚¹ãƒ†ãƒ¼ã‚¸ã®é †æ¬¡å®Ÿè¡Œ
      for (const [stageName, stage] of this.stages) {
        if (stage.environment && stage.environment !== build.environment) {
          continue;
        }

        console.log(`\nğŸ“‹ ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å®Ÿè¡Œä¸­: ${stage.name}`);
        const stageResult = await this.executeStage(build, stageName, stage);
        build.stages.push(stageResult);

        if (stageResult.status === 'failed' && stage.required) {
          throw new Error(`Required stage ${stageName} failed`);
        }
      }

      // å¾Œå‡¦ç†
      await this.postBuild(build);

      build.status = 'success';
      build.endTime = new Date();
      build.duration = build.endTime - build.startTime;

      console.log(`âœ… ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãŒæˆåŠŸã—ã¾ã—ãŸ: ${buildId}`);
      console.log(`â±ï¸  æ‰€è¦æ™‚é–“: ${Math.round(build.duration / 1000)}ç§’`);

    } catch (error) {
      build.status = 'failed';
      build.endTime = new Date();
      build.duration = build.endTime - build.startTime;
      build.error = error.message;

      console.error(`âŒ ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãŒå¤±æ•—ã—ã¾ã—ãŸ: ${buildId}`);
      console.error(`ã‚¨ãƒ©ãƒ¼: ${error.message}`);

      // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®å®Ÿè¡Œ
      await this.rollback(build);
    }

    // ãƒ“ãƒ«ãƒ‰å±¥æ­´ã«è¿½åŠ 
    this.buildHistory.push(build);

    // é€šçŸ¥ã®é€ä¿¡
    await this.sendNotifications(build);

    // ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
    const report = this.generateBuildReport(build);
    console.log('\nğŸ“Š ãƒ“ãƒ«ãƒ‰ãƒ¬ãƒãƒ¼ãƒˆ:');
    console.log(report);

    return build;
  }

  // ã‚¹ãƒ†ãƒ¼ã‚¸ã®å®Ÿè¡Œ
  async executeStage(build, stageName, stage) {
    const stageStart = Date.now();
    const stageResult = {
      name: stageName,
      status: 'running',
      startTime: new Date(),
      logs: [],
      artifacts: [],
      metrics: {}
    };

    try {
      // å‰å‡¦ç†
      await this.preStage(build, stageName);

      // ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè¡Œ
      const result = await this.executeScript(stage.script, {
        timeout: stage.timeout,
        cwd: build.workspace,
        env: {
          ...process.env,
          BUILD_ID: build.id,
          STAGE_NAME: stageName,
          BRANCH_NAME: build.branch
        }
      });

      stageResult.status = 'success';
      stageResult.output = result.output;
      stageResult.logs = result.logs;

      // æˆåŠŸãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®è¨˜éŒ²
      this.recordMetrics(stageName, 'success', Date.now() - stageStart);

      // ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®åé›†
      if (stage.artifacts) {
        const artifacts = await this.collectArtifacts(stage.artifacts);
        stageResult.artifacts = artifacts;
        build.artifacts.push(...artifacts);
      }

      // å“è³ªã‚²ãƒ¼ãƒˆã®ãƒã‚§ãƒƒã‚¯
      if (stageName === 'quality') {
        const qualityResult = await this.checkQualityGates(build);
        stageResult.qualityMetrics = qualityResult;
        build.qualityMetrics = qualityResult;
      }

      console.log(`âœ… ${stageName} ã‚¹ãƒ†ãƒ¼ã‚¸ãŒæˆåŠŸã—ã¾ã—ãŸ`);

    } catch (error) {
      stageResult.status = 'failed';
      stageResult.error = error.message;
      stageResult.endTime = new Date();

      // å¤±æ•—ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®è¨˜éŒ²
      this.recordMetrics(stageName, 'failed', Date.now() - stageStart);

      console.error(`âŒ ${stageName} ã‚¹ãƒ†ãƒ¼ã‚¸ãŒå¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
    }

    stageResult.endTime = new Date();
    stageResult.duration = stageResult.endTime - stageResult.startTime;

    // å¾Œå‡¦ç†
    await this.postStage(build, stageName, stageResult);

    return stageResult;
  }

  // ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè¡Œ
  async executeScript(script, options = {}) {
    const timeout = options.timeout || 300000; // 5åˆ†ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    const cwd = options.cwd || process.cwd();
    const env = options.env || process.env;

    console.log(`ğŸ”§ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™: ${script}`);

    return new Promise((resolve, reject) => {
      const child = require('child_process').exec(script, {
        cwd,
        env,
        timeout,
        maxBuffer: 1024 * 1024 * 10 // 10MB
      });

      let stdout = '';
      let stderr = '';
      const logs = [];

      child.stdout?.on('data', (data) => {
        stdout += data;
        logs.push({ type: 'stdout', data: data.toString(), timestamp: Date.now() });
        console.log(data.toString().trim());
      });

      child.stderr?.on('data', (data) => {
        stderr += data;
        logs.push({ type: 'stderr', data: data.toString(), timestamp: Date.now() });
        console.error(data.toString().trim());
      });

      child.on('close', (code) => {
        if (code === 0) {
          resolve({
            code,
            output: stdout,
            error: stderr,
            logs
          });
        } else {
          reject(new Error(`Script failed with exit code ${code}: ${stderr}`));
        }
      });

      child.on('error', (error) => {
        reject(error);
      });
    });
  }

  // å“è³ªã‚²ãƒ¼ãƒˆã®ãƒã‚§ãƒƒã‚¯
  async checkQualityGates(build) {
    console.log('ğŸ” å“è³ªã‚²ãƒ¼ãƒˆã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™...');

    const qualityMetrics = {
      codeCoverage: 0,
      codeQuality: 0,
      security: 0,
      performance: 0,
      overall: 0
    };

    try {
      // ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®ãƒã‚§ãƒƒã‚¯
      const coverage = await this.checkTestCoverage();
      qualityMetrics.codeCoverage = coverage;

      // ã‚³ãƒ¼ãƒ‰å“è³ªã®ãƒã‚§ãƒƒã‚¯
      const quality = await this.checkCodeQuality();
      qualityMetrics.codeQuality = quality;

      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
      const security = await this.runSecurityScan();
      qualityMetrics.security = security;

      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
      const performance = await this.runPerformanceTests();
      qualityMetrics.performance = performance;

      // ç·åˆã‚¹ã‚³ã‚¢ã®è¨ˆç®—
      qualityMetrics.overall = Math.round(
        (coverage * 0.3 + quality * 0.3 + security * 0.2 + performance * 0.2)
      );

      // å“è³ªã‚²ãƒ¼ãƒˆã®æ¤œè¨¼
      const gates = this.config.qualityGates || {
        minCodeCoverage: 80,
        minCodeQuality: 85,
        minSecurity: 90,
        minPerformance: 75,
        minOverall: 80
      };

      const gateResults = {
        codeCoverage: coverage >= gates.minCodeCoverage,
        codeQuality: quality >= gates.minCodeQuality,
        security: security >= gates.minSecurity,
        performance: performance >= gates.minPerformance,
        overall: qualityMetrics.overall >= gates.minOverall
      };

      const passedGates = Object.values(gateResults).filter(Boolean).length;
      const totalGates = Object.keys(gateResults).length;

      console.log(`ğŸ“Š å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹:`);
      console.log(`  ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸: ${coverage}% (${gateResults.codeCoverage ? 'âœ…' : 'âŒ'})`);
      console.log(`  ã‚³ãƒ¼ãƒ‰å“è³ª: ${quality}% (${gateResults.codeQuality ? 'âœ…' : 'âŒ'})`);
      console.log(`  ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£: ${security}% (${gateResults.security ? 'âœ…' : 'âŒ'})`);
      console.log(`  ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹: ${performance}% (${gateResults.performance ? 'âœ…' : 'âŒ'})`);
      console.log(`  ç·åˆã‚¹ã‚³ã‚¢: ${qualityMetrics.overall}% (${gateResults.overall ? 'âœ…' : 'âŒ'})`);

      if (passedGates < totalGates) {
        throw new Error(`Quality gates failed: ${passedGates}/${totalGates} passed`);
      }

      return {
        ...qualityMetrics,
        gates: gateResults,
        passed: passedGates === totalGates
      };

    } catch (error) {
      console.error('âŒ å“è³ªã‚²ãƒ¼ãƒˆã®ãƒã‚§ãƒƒã‚¯ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      throw error;
    }
  }

  // ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ã®ãƒã‚§ãƒƒã‚¯
  async checkTestCoverage() {
    try {
      // ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
      await this.executeScript('npm run test:coverage', { timeout: 300000 });

      // ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®è§£æ
      const coverageReport = await this.parseCoverageReport();

      return coverageReport.totalCoverage || 0;
    } catch (error) {
      console.error('ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸ãƒã‚§ãƒƒã‚¯ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      return 0;
    }
  }

  // ã‚³ãƒ¼ãƒ‰å“è³ªã®ãƒã‚§ãƒƒã‚¯
  async checkCodeQuality() {
    try {
      // ESLintã®å®Ÿè¡Œ
      const eslintResult = await this.executeScript('npm run lint', { timeout: 120000 });

      // è¤‡é›‘æ€§ã®ãƒã‚§ãƒƒã‚¯
      const complexityResult = await this.executeScript('npm run complexity', { timeout: 120000 });

      // å“è³ªã‚¹ã‚³ã‚¢ã®è¨ˆç®—
      const qualityScore = this.calculateQualityScore(eslintResult, complexityResult);

      return qualityScore;
    } catch (error) {
      console.error('ã‚³ãƒ¼ãƒ‰å“è³ªãƒã‚§ãƒƒã‚¯ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      return 0;
    }
  }

  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ã®å®Ÿè¡Œ
  async runSecurityScan() {
    try {
      // ä¾å­˜é–¢ä¿‚ã®è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³
      const auditResult = await this.executeScript('npm audit --audit-level=moderate', { timeout: 180000 });

      // é™çš„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ†æ
      const sastResult = await this.executeScript('npm run security-scan', { timeout: 300000 });

      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚³ã‚¢ã®è¨ˆç®—
      const securityScore = this.calculateSecurityScore(auditResult, sastResult);

      return securityScore;
    } catch (error) {
      console.error('ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      return 0;
    }
  }

  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
  async runPerformanceTests() {
    try {
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
      const perfResult = await this.executeScript('npm run performance-test', { timeout: 600000 });

      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¹ã‚³ã‚¢ã®è¨ˆç®—
      const performanceScore = this.calculatePerformanceScore(perfResult);

      return performanceScore;
    } catch (error) {
      console.error('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      return 0;
    }
  }

  // ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®åé›†
  async collectArtifacts(patterns) {
    const artifacts = [];

    for (const pattern of patterns) {
      const files = await this.findFiles(pattern);
      for (const file of files) {
        const artifact = {
          name: path.basename(file),
          path: file,
          size: fs.statSync(file).size,
          type: this.getArtifactType(file)
        };
        artifacts.push(artifact);
      }
    }

    console.log(`ğŸ“¦ ${artifacts.length}å€‹ã®ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã‚’åé›†ã—ã¾ã—ãŸ`);
    return artifacts;
  }

  // ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œç´¢
  async findFiles(pattern) {
    const { glob } = await import('glob');
    return glob.sync(pattern);
  }

  // ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã®åˆ¤å®š
  getArtifactType(filename) {
    const ext = path.extname(filename).toLowerCase();
    const typeMap = {
      '.js': 'javascript',
      '.ts': 'typescript',
      '.jsx': 'react',
      '.tsx': 'react-typescript',
      '.css': 'stylesheet',
      '.scss': 'stylesheet',
      '.json': 'json',
      '.html': 'html',
      '.md': 'documentation',
      '.zip': 'archive',
      '.tar.gz': 'archive'
    };
    return typeMap[ext] || 'unknown';
  }

  // ãƒ“ãƒ«ãƒ‰å‰å‡¦ç†
  async preBuild(build) {
    console.log('ğŸ”§ ãƒ“ãƒ«ãƒ‰å‰å‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™...');

    // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã®æº–å‚™
    build.workspace = await this.prepareWorkspace();

    // ã‚³ãƒ¼ãƒ‰ã®ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
    await this.checkoutCode(build);

    // ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
    await this.installDependencies(build);

    // ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
    await this.setupEnvironment(build);
  }

  // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã®æº–å‚™
  async prepareWorkspace() {
    const workspace = path.join(process.cwd(), 'build', Date.now().toString());

    if (!fs.existsSync(workspace)) {
      fs.mkdirSync(workspace, { recursive: true });
    }

    return workspace;
  }

  // ã‚³ãƒ¼ãƒ‰ã®ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
  async checkoutCode(build) {
    if (build.commit) {
      console.log(`ğŸ“¥ ã‚³ãƒŸãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆã—ã¾ã™: ${build.commit}`);
      await this.executeScript(`git checkout ${build.commit}`, { cwd: build.workspace });
    }
  }

  // ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
  async installDependencies(build) {
    console.log('ğŸ“¦ ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™...');
    await this.executeScript('npm ci', { cwd: build.workspace, timeout: 600000 });
  }

  // ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
  async setupEnvironment(build) {
    console.log('ğŸ”§ ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¾ã™...');

    const envFile = path.join(build.workspace, '.env');
    const envConfig = this.config.environments[build.environment] || {};

    const envContent = Object.entries(envConfig)
      .map(([key, value]) => `${key}=${value}`)
      .join('\n');

    fs.writeFileSync(envFile, envContent);
  }

  // ãƒ“ãƒ«ãƒ‰å¾Œå‡¦ç†
  async postBuild(build) {
    console.log('ğŸ§¹ ãƒ“ãƒ«ãƒ‰å¾Œå‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™...');

    // ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    if (build.artifacts.length > 0) {
      await this.uploadArtifacts(build);
    }

    // ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®å®Ÿè¡Œ
    if (build.status === 'success' && build.environment !== 'build') {
      await this.deploy(build);
    }

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await this.cleanup(build);
  }

  // ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
  async uploadArtifacts(build) {
    console.log(`ğŸ“¤ ${build.artifacts.length}å€‹ã®ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™...`);

    for (const artifact of build.artifacts) {
      try {
        await this.uploadArtifact(artifact);
        console.log(`  âœ… ${artifact.name}`);
      } catch (error) {
        console.error(`  âŒ ${artifact.name}: ${error.message}`);
      }
    }
  }

  // ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆå€‹åˆ¥ï¼‰
  async uploadArtifact(artifact) {
    // å®Ÿéš›ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    // S3ã€Artifactoryã€ã¾ãŸã¯ç‹¬è‡ªã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ä½¿ç”¨
    console.log(`Uploading ${artifact.path} to artifact storage...`);
  }

  // ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®å®Ÿè¡Œ
  async deploy(build) {
    console.log(`ğŸš€ ${build.environment} ç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™...`);

    const deployStrategy = this.config.deployStrategy || 'blue-green';

    switch (deployStrategy) {
      case 'blue-green':
        await this.blueGreenDeploy(build);
        break;
      case 'canary':
        await this.canaryDeploy(build);
        break;
      case 'rolling':
        await this.rollingDeploy(build);
        break;
      default:
        await this.basicDeploy(build);
    }
  }

  // Blue-Greenãƒ‡ãƒ—ãƒ­ã‚¤
  async blueGreenDeploy(build) {
    console.log('ğŸ”„ Blue-Greenãƒ‡ãƒ—ãƒ­ã‚¤ã‚’å®Ÿè¡Œã—ã¾ã™...');

    // æ–°ã—ã„ç’°å¢ƒï¼ˆGreenï¼‰ã®æº–å‚™
    const greenEnv = `${build.environment}-green`;

    // Greenç’°å¢ƒã¸ã®ãƒ‡ãƒ—ãƒ­ã‚¤
    await this.deployToEnvironment(build, greenEnv);

    // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
    const healthCheck = await this.performHealthCheck(greenEnv);
    if (!healthCheck.healthy) {
      throw new Error('Green environment health check failed');
    }

    // ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã®åˆ‡ã‚Šæ›¿ãˆ
    await this.switchTraffic(build.environment, greenEnv);

    // æ—§ç’°å¢ƒï¼ˆBlueï¼‰ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await this.cleanupEnvironment(build.environment);

    console.log('âœ… Blue-Greenãƒ‡ãƒ—ãƒ­ã‚¤ãŒå®Œäº†ã—ã¾ã—ãŸ');
  }

  // ã‚«ãƒŠãƒªã‚¢ãƒ‡ãƒ—ãƒ­ã‚¤
  async canaryDeploy(build) {
    console.log('ğŸ¦ ã‚«ãƒŠãƒªã‚¢ãƒ‡ãƒ—ãƒ­ã‚¤ã‚’å®Ÿè¡Œã—ã¾ã™...');

    // 10%ã®ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’æ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«
    await this.deployWithTrafficControl(build, 10);

    // ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
    const monitoring = await this.monitorDeployment(build, 300000); // 5åˆ†

    if (monitoring.healthy) {
      // æ®µéšçš„ã«ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’å¢—åŠ 
      await this.adjustTraffic(build, 50);
      await this.monitorDeployment(build, 300000);

      await this.adjustTraffic(build, 100);
      console.log('âœ… ã‚«ãƒŠãƒªã‚¢ãƒ‡ãƒ—ãƒ­ã‚¤ãŒå®Œäº†ã—ã¾ã—ãŸ');
    } else {
      // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
      await this.rollbackTraffic(build);
      throw new Error('Canary deployment failed');
    }
  }

  // ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒ‡ãƒ—ãƒ­ã‚¤
  async rollingDeploy(build) {
    console.log('ğŸ”„ ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒ‡ãƒ—ãƒ­ã‚¤ã‚’å®Ÿè¡Œã—ã¾ã™...');

    const instances = await this.getInstances(build.environment);
    const batchSize = Math.max(1, Math.floor(instances.length / 3));

    for (let i = 0; i < instances.length; i += batchSize) {
      const batch = instances.slice(i, i + batchSize);

      // ãƒãƒƒãƒã‚’ãƒ‡ãƒ—ãƒ­ã‚¤
      for (const instance of batch) {
        await this.deployToInstance(build, instance);
      }

      // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
      const healthy = await this.checkBatchHealth(batch);
      if (!healthy) {
        throw new Error('Rolling deployment health check failed');
      }

      console.log(`âœ… ãƒãƒƒãƒ ${Math.floor(i / batchSize) + 1}/${Math.ceil(instances.length / batchSize)} ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã—ãŸ`);
    }

    console.log('âœ… ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒ‡ãƒ—ãƒ­ã‚¤ãŒå®Œäº†ã—ã¾ã—ãŸ');
  }

  // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  async performHealthCheck(environment) {
    try {
      const url = this.getEnvironmentUrl(environment);
      const response = await axios.get(`${url}/health`, { timeout: 10000 });

      return {
        healthy: response.data.status === 'healthy',
        response: response.data,
        responseTime: response.headers['x-response-time']
      };
    } catch (error) {
      return { healthy: false, error: error.message };
    }
  }

  // ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
  async monitorDeployment(build, duration) {
    const startTime = Date.now();
    let healthy = true;

    while (Date.now() - startTime < duration) {
      const health = await this.performHealthCheck(build.environment);

      if (!health.healthy) {
        healthy = false;
        break;
      }

      // ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒ¼ãƒˆã®ãƒã‚§ãƒƒã‚¯
      const errorRate = await this.getErrorRate(build.environment);
      if (errorRate > 5) { // 5%ä»¥ä¸Šã®ã‚¨ãƒ©ãƒ¼ç‡
        healthy = false;
        break;
      }

      await new Promise(resolve => setTimeout(resolve, 30000)); // 30ç§’å¾…æ©Ÿ
    }

    return { healthy, duration: Date.now() - startTime };
  }

  // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®å®Ÿè¡Œ
  async rollback(build) {
    console.log('ğŸ”„ ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™...');

    if (build.previousDeployment) {
      await this.deployToVersion(build, build.previousDeployment);
      console.log('âœ… ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå®Œäº†ã—ã¾ã—ãŸ');
    } else {
      console.log('âš ï¸  ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }
  }

  // é€šçŸ¥ã®é€ä¿¡
  async sendNotifications(build) {
    console.log('ğŸ“§ é€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã™...');

    for (const notification of this.config.notifications) {
      try {
        await this.sendNotification(build, notification);
        console.log(`  âœ… ${notification.type}`);
      } catch (error) {
        console.error(`  âŒ ${notification.type}: ${error.message}`);
      }
    }
  }

  // é€šçŸ¥ã®é€ä¿¡ï¼ˆå€‹åˆ¥ï¼‰
  async sendNotification(build, notification) {
    const message = this.formatNotificationMessage(build);

    switch (notification.type) {
      case 'slack':
        await this.sendSlackNotification(notification.webhook, message);
        break;
      case 'email':
        await this.sendEmailNotification(notification.recipients, message);
        break;
      case 'webhook':
        await this.sendWebhookNotification(notification.url, message);
        break;
      default:
        console.log(`Unknown notification type: ${notification.type}`);
    }
  }

  // é€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
  formatNotificationMessage(build) {
    const status = build.status === 'success' ? 'âœ…' : 'âŒ';
    const duration = Math.round(build.duration / 1000);

    return {
      text: `${status} ${this.config.projectName} Build #${build.id.slice(-6)}`,
      attachments: [{
        color: build.status === 'success' ? 'good' : 'danger',
        fields: [
          { title: 'Status', value: build.status, short: true },
          { title: 'Duration', value: `${duration}s`, short: true },
          { title: 'Branch', value: build.branch, short: true },
          { title: 'Environment', value: build.environment, short: true },
          { title: 'Commit', value: build.commit.slice(0, 7), short: true }
        ]
      }]
    };
  }

  // Slacké€šçŸ¥ã®é€ä¿¡
  async sendSlackNotification(webhook, message) {
    await axios.post(webhook, message);
  }

  // ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ã®é€ä¿¡
  async sendEmailNotification(recipients, message) {
    // å®Ÿéš›ã®ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    console.log(`Sending email to ${recipients.join(', ')}`);
  }

  // Webhooké€šçŸ¥ã®é€ä¿¡
  async sendWebhookNotification(url, message) {
    await axios.post(url, message);
  }

  // ãƒ“ãƒ«ãƒ‰ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
  generateBuildReport(build) {
    const stages = build.stages.map(stage =>
      `${stage.name}: ${stage.status} (${Math.round(stage.duration / 1000)}s)`
    ).join('\n  ');

    return `
Build Report
=============
ID: ${build.id}
Status: ${build.status}
Duration: ${Math.round(build.duration / 1000)}s
Branch: ${build.branch}
Environment: ${build.environment}
Commit: ${build.commit}

Stages:
  ${stages}

Artifacts: ${build.artifacts.length}
Quality Score: ${build.qualityMetrics.overall || 'N/A'}%
    `.trim();
  }

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
  generateBuildId() {
    return `build_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
  }

  getCurrentCommit() {
    try {
      return execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim();
    } catch (error) {
      return 'unknown';
    }
  }

  recordMetrics(stage, status, duration) {
    const key = `${stage}_${status}`;
    if (!this.qualityMetrics.has(key)) {
      this.qualityMetrics.set(key, []);
    }
    this.qualityMetrics.get(key).push(duration);
  }

  parseCoverageReport() {
    // å®Ÿéš›ã®ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆè§£æãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    return { totalCoverage: 85 };
  }

  calculateQualityScore(eslintResult, complexityResult) {
    // å®Ÿéš›ã®å“è³ªã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    return 90;
  }

  calculateSecurityScore(auditResult, sastResult) {
    // å®Ÿéš›ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    return 95;
  }

  calculatePerformanceScore(perfResult) {
    // å®Ÿéš›ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    return 88;
  }

  getEnvironmentUrl(environment) {
    // ç’°å¢ƒã«å¿œã˜ãŸURLã‚’è¿”ã™
    return `https://${environment}.example.com`;
  }

  getInstances(environment) {
    // ç’°å¢ƒã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒªã‚¹ãƒˆã‚’è¿”ã™
    return [
      { id: 'instance-1', host: '10.0.1.1' },
      { id: 'instance-2', host: '10.0.1.2' },
      { id: 'instance-3', host: '10.0.1.3' }
    ];
  }

  getErrorRate(environment) {
    // ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒ¼ãƒˆã‚’è¿”ã™ï¼ˆå®Ÿéš›ã«ã¯ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰å–å¾—ï¼‰
    return Math.random() * 10;
  }

  // ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
  async deployToEnvironment(build, environment) {
    console.log(`Deploying to ${environment}...`);
  }

  async switchTraffic(from, to) {
    console.log(`Switching traffic from ${from} to ${to}...`);
  }

  async cleanupEnvironment(environment) {
    console.log(`Cleaning up ${environment}...`);
  }

  async deployWithTrafficControl(build, percentage) {
    console.log(`Deploying with ${percentage}% traffic...`);
  }

  async adjustTraffic(build, percentage) {
    console.log(`Adjusting traffic to ${percentage}%...`);
  }

  async rollbackTraffic(build) {
    console.log('Rolling back traffic...');
  }

  async checkBatchHealth(instances) {
    console.log(`Checking health of batch: ${instances.map(i => i.id).join(', ')}`);
    return true;
  }

  async deployToInstance(build, instance) {
    console.log(`Deploying to instance ${instance.id}...`);
  }

  async deployToVersion(build, version) {
    console.log(`Deploying to version ${version}...`);
  }

  async cleanup(build) {
    console.log(`Cleaning up workspace: ${build.workspace}`);
    // ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’å®Ÿè£…
  }

  // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ•ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰
  async preStage(build, stageName) {
    console.log(`Pre-stage hook for ${stageName}`);
  }

  async postStage(build, stageName, stageResult) {
    console.log(`Post-stage hook for ${stageName}`);
  }
}

module.exports = { CICDPipeline };
```

:::

## DevOpsãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

DevOpsã¯é–‹ç™ºã¨é‹ç”¨ã®å”æ¥­ã‚’ä¿ƒé€²ã™ã‚‹æ–‡åŒ–ã¨ãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã®é›†åˆã§ã™ã€‚

:::step

1. DevOpsãƒ„ãƒ¼ãƒ«ãƒã‚§ãƒ¼ãƒ³ã®å®Ÿè£…

`src/devops-toolchain.js`ã‚’ä½œæˆã—ã€Claude Codeã‚’æ´»ç”¨ã—ãŸDevOpsãƒ„ãƒ¼ãƒ«ãƒã‚§ãƒ¼ãƒ³ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

_src/devops-toolchain.js_

```javascript
/**
 * Claude Codeã‚’æ´»ç”¨ã—ãŸDevOpsãƒ„ãƒ¼ãƒ«ãƒã‚§ãƒ¼ãƒ³
 * ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å³æ™‚ã‚³ãƒ¼ãƒ‰ã€ç›£è¦–ã€ãƒ­ã‚®ãƒ³ã‚°ãªã©ã®æ©Ÿèƒ½ã‚’æä¾›
 */
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class DevOpsToolchain {
  constructor(config = {}) {
    this.config = {
      projectName: config.projectName || 'my-project',
      cloudProvider: config.cloudProvider || 'aws',
      region: config.region || 'us-east-1',
      environment: config.environment || 'development',
      monitoring: config.monitoring || {},
      logging: config.logging || {},
      ...config
    };

    this.infrastructure = new InfrastructureManager(this.config);
    this.monitoring = new MonitoringService(this.config.monitoring);
    this.logging = new LoggingService(this.config.logging);
    this.security = new SecurityService(this.config);
    this.backup = new BackupService(this.config);
  }

  // ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã®ç®¡ç†
  async manageInfrastructure() {
    console.log('ğŸ—ï¸  ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã‚’ç®¡ç†ã—ã¾ã™...');

    // Terraformã¾ãŸã¯CloudFormationã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ
    const infrastructureTemplate = await this.generateInfrastructureTemplate();

    // ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã®ãƒ‡ãƒ—ãƒ­ã‚¤
    const deployment = await this.deployInfrastructure(infrastructureTemplate);

    // è¨­å®šã®æ¤œè¨¼
    const validation = await this.validateInfrastructure(deployment);

    return {
      template: infrastructureTemplate,
      deployment,
      validation
    };
  }

  // ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ç”Ÿæˆ
  async generateInfrastructureTemplate() {
    console.log('ğŸ“‹ ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã™...');

    const prompt = `
ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«æœ€é©ãªã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¦ãã ã•ã„:

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå: ${this.config.projectName}
ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼: ${this.config.cloudProvider}
ç’°å¢ƒ: ${this.config.environment}
ãƒªãƒ¼ã‚¸ãƒ§ãƒ³: ${this.config.region}

è¦ä»¶:
- é«˜å¯ç”¨æ€§
- è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
- è² è·åˆ†æ•£
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å†—é•·åŒ–
- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¨å¾©å…ƒ
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚°ãƒ«ãƒ¼ãƒ—ã®è¨­å®š
- ç›£è¦–ã¨ãƒ­ã‚®ãƒ³ã‚°

ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå½¢å¼:
- AWSã®å ´åˆ: CloudFormationã¾ãŸã¯Terraform
- GCPã®å ´åˆ: Deployment Manager
- Azureã®å ´åˆ: ARMãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
`;

    // Claude Codeã«ã‚ˆã‚‹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    const template = this.generateMockInfrastructureTemplate();

    console.log('âœ… ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸ');
    return template;
  }

  // ãƒ¢ãƒƒã‚¯ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ç”Ÿæˆ
  generateMockInfrastructureTemplate() {
    return {
      provider: this.config.cloudProvider,
      resources: {
        vpc: {
          type: 'AWS::EC2::VPC',
          properties: {
            CidrBlock: '10.0.0.0/16',
            EnableDnsSupport: true,
            EnableDnsHostnames: true,
            Tags: [
              { Key: 'Name', Value: `${this.config.projectName}-vpc` },
              { Key: 'Environment', Value: this.config.environment }
            ]
          }
        },
        loadBalancer: {
          type: 'AWS::ElasticLoadBalancingV2::LoadBalancer',
          properties: {
            Type: 'application',
            Scheme: 'internet-facing',
            Subnets: [],
            SecurityGroups: []
          }
        },
        autoScaling: {
          type: 'AWS::AutoScaling::AutoScalingGroup',
          properties: {
            MinSize: 2,
            MaxSize: 10,
            DesiredCapacity: 2,
            HealthCheckType: 'ELB',
            HealthCheckGracePeriod: 300
          }
        }
      },
      outputs: {
        LoadBalancerDNS: {
          Description: 'DNS name of the load balancer',
          Value: { 'Fn::GetAtt': ['LoadBalancer', 'DNSName'] }
        }
      }
    };
  }

  // ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã®ãƒ‡ãƒ—ãƒ­ã‚¤
  async deployInfrastructure(template) {
    console.log('ğŸš€ ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™...');

    try {
      // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®æ¤œè¨¼
      await this.validateTemplate(template);

      // ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®å®Ÿè¡Œ
      const deployment = {
        id: this.generateDeploymentId(),
        status: 'deploying',
        startTime: new Date(),
        template: template,
        resources: [],
        outputs: {}
      };

      // å„ãƒªã‚½ãƒ¼ã‚¹ã®ãƒ‡ãƒ—ãƒ­ã‚¤
      for (const [resourceName, resourceConfig] of Object.entries(template.resources || {})) {
        const resource = await this.deployResource(resourceName, resourceConfig);
        deployment.resources.push(resource);
      }

      // ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆã®åé›†
      for (const [outputName, outputConfig] of Object.entries(template.outputs || {})) {
        deployment.outputs[outputName] = await this.getOutputValue(outputConfig);
      }

      deployment.status = 'deployed';
      deployment.endTime = new Date();

      console.log('âœ… ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã®ãƒ‡ãƒ—ãƒ­ã‚¤ãŒå®Œäº†ã—ã¾ã—ãŸ');
      return deployment;

    } catch (error) {
      console.error('âŒ ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã®ãƒ‡ãƒ—ãƒ­ã‚¤ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
      throw error;
    }
  }

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®æ¤œè¨¼
  async validateTemplate(template) {
    console.log('ğŸ” ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’æ¤œè¨¼ã—ã¾ã™...');

    const errors = [];

    // å¿…é ˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ãƒã‚§ãƒƒã‚¯
    if (!template.provider) {
      errors.push('Provider is required');
    }

    if (!template.resources || Object.keys(template.resources).length === 0) {
      errors.push('At least one resource is required');
    }

    // ãƒªã‚½ãƒ¼ã‚¹ã®æ¤œè¨¼
    for (const [resourceName, resourceConfig] of Object.entries(template.resources || {})) {
      if (!resourceConfig.type) {
        errors.push(`Resource ${resourceName} missing type`);
      }
      if (!resourceConfig.properties) {
        errors.push(`Resource ${resourceName} missing properties`);
      }
    }

    if (errors.length > 0) {
      throw new Error(`Template validation failed: ${errors.join(', ')}`);
    }

    console.log('âœ… ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®æ¤œè¨¼ãŒå®Œäº†ã—ã¾ã—ãŸ');
  }

  // ãƒªã‚½ãƒ¼ã‚¹ã®ãƒ‡ãƒ—ãƒ­ã‚¤
  async deployResource(resourceName, resourceConfig) {
    console.log(`ğŸ“¦ ãƒªã‚½ãƒ¼ã‚¹ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™: ${resourceName}`);

    // å®Ÿéš›ã®ã‚¯ãƒ©ã‚¦ãƒ‰APIå‘¼ã³å‡ºã—ï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    const resource = {
      name: resourceName,
      type: resourceConfig.type,
      id: this.generateResourceId(),
      status: 'created',
      properties: resourceConfig.properties,
      createdAt: new Date()
    };

    // ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    await new Promise(resolve => setTimeout(resolve, 1000));

    console.log(`âœ… ${resourceName} ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã—ãŸ`);
    return resource;
  }

  // ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆå€¤ã®å–å¾—
  async getOutputValue(outputConfig) {
    // å®Ÿéš›ã®å‡ºåŠ›å€¤ã®å–å¾—ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    return 'example-output-value';
  }

  // ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã®æ¤œè¨¼
  async validateInfrastructure(deployment) {
    console.log('ğŸ” ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ã‚’æ¤œè¨¼ã—ã¾ã™...');

    const validation = {
      status: 'valid',
      checks: [],
      issues: [],
      timestamp: new Date()
    };

    // å„ãƒªã‚½ãƒ¼ã‚¹ã®æ¤œè¨¼
    for (const resource of deployment.resources) {
      const check = await this.validateResource(resource);
      validation.checks.push(check);

      if (!check.healthy) {
        validation.issues.push(...check.issues);
      }
    }

    // å…¨ä½“ã®å¥å…¨æ€§åˆ¤å®š
    const unhealthyChecks = validation.checks.filter(c => !c.healthy);
    if (unhealthyChecks.length > 0) {
      validation.status = 'invalid';
      validation.issues.unshift(`${unhealthyChecks.length} resources are unhealthy`);
    }

    console.log(`âœ… æ¤œè¨¼ãŒå®Œäº†ã—ã¾ã—ãŸ: ${validation.status}`);
    return validation;
  }

  // ãƒªã‚½ãƒ¼ã‚¹ã®æ¤œè¨¼
  async validateResource(resource) {
    console.log(`ğŸ” ãƒªã‚½ãƒ¼ã‚¹ã‚’æ¤œè¨¼ã—ã¾ã™: ${resource.name}`);

    const check = {
      resource: resource.name,
      healthy: true,
      issues: [],
      metrics: {}
    };

    try {
      // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
      const health = await this.checkResourceHealth(resource);
      check.healthy = health.healthy;
      check.metrics.health = health;

      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹
      const performance = await this.getResourcePerformance(resource);
      check.metrics.performance = performance;

      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
      const security = await this.checkResourceSecurity(resource);
      check.metrics.security = security;

      if (!check.healthy) {
        check.issues.push('Resource is unhealthy');
      }

    } catch (error) {
      check.healthy = false;
      check.issues.push(error.message);
    }

    return check;
  }

  // ãƒªã‚½ãƒ¼ã‚¹ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  async checkResourceHealth(resource) {
    // å®Ÿéš›ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    return {
      healthy: Math.random() > 0.1, // 90%ã®ç¢ºç‡ã§æ­£å¸¸
      responseTime: Math.floor(Math.random() * 1000),
      lastChecked: new Date()
    };
  }

  // ãƒªã‚½ãƒ¼ã‚¹ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å–å¾—
  async getResourcePerformance(resource) {
    // å®Ÿéš›ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    return {
      cpu: Math.floor(Math.random() * 100),
      memory: Math.floor(Math.random() * 100),
      network: Math.floor(Math.random() * 1000),
      disk: Math.floor(Math.random() * 100)
    };
  }

  // ãƒªã‚½ãƒ¼ã‚¹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
  async checkResourceSecurity(resource) {
    // å®Ÿéš›ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    return {
      score: Math.floor(Math.random() * 50) + 50, // 50-100ã®ã‚¹ã‚³ã‚¢
      vulnerabilities: Math.floor(Math.random() * 3),
      lastScan: new Date()
    };
  }

  // ç›£è¦–ã®è¨­å®š
  async setupMonitoring() {
    console.log('ğŸ“Š ç›£è¦–ã‚’è¨­å®šã—ã¾ã™...');

    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã®è¨­å®š
    const metricsConfig = await this.configureMetrics();

    // ã‚¢ãƒ©ãƒ¼ãƒˆãƒ«ãƒ¼ãƒ«ã®è¨­å®š
    const alertRules = await this.configureAlerts();

    // ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã®ä½œæˆ
    const dashboards = await this.createDashboards();

    return {
      metrics: metricsConfig,
      alerts: alertRules,
      dashboards
    };
  }

  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨­å®šã®æ§‹æˆ
  async configureMetrics() {
    console.log('ğŸ“ˆ ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã‚’è¨­å®šã—ã¾ã™...');

    const metrics = [
      {
        name: 'CPUUtilization',
        namespace: 'AWS/EC2',
        statistic: 'Average',
        period: 300
      },
      {
        name: 'MemoryUtilization',
        namespace: 'System/Linux',
        statistic: 'Average',
        period: 300
      },
      {
        name: 'ResponseTime',
        namespace: 'Application',
        statistic: 'Average',
        period: 60
      }
    ];

    const config = {
      collection: {
        enabled: true,
        interval: 60,
        metrics
      },
      retention: {
        days: 30
      }
    };

    console.log('âœ… ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨­å®šã‚’æ§‹æˆã—ã¾ã—ãŸ');
    return config;
  }

  // ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®šã®æ§‹æˆ
  async configureAlerts() {
    console.log('ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆãƒ«ãƒ¼ãƒ«ã‚’è¨­å®šã—ã¾ã™...');

    const alerts = [
      {
        name: 'HighCPU',
        metric: 'CPUUtilization',
        threshold: 80,
        comparison: 'greater_than',
        duration: 300,
        actions: ['notification', 'autoscale']
      },
      {
        name: 'HighMemory',
        metric: 'MemoryUtilization',
        threshold: 90,
        comparison: 'greater_than',
        duration: 300,
        actions: ['notification']
      },
      {
        name: 'HighErrorRate',
        metric: 'ErrorRate',
        threshold: 5,
        comparison: 'greater_than',
        duration: 300,
        actions: ['notification', 'rollback']
      }
    ];

    const config = {
      enabled: true,
      rules: alerts,
      channels: ['email', 'slack', 'pagerduty']
    };

    console.log('âœ… ã‚¢ãƒ©ãƒ¼ãƒˆãƒ«ãƒ¼ãƒ«ã‚’è¨­å®šã—ã¾ã—ãŸ');
    return config;
  }

  // ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã®ä½œæˆ
  async createDashboards() {
    console.log('ğŸ“Š ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¾ã™...');

    const dashboards = [
      {
        name: 'System Overview',
        widgets: [
          {
            type: 'metric',
            title: 'CPU Utilization',
            metrics: ['CPUUtilization']
          },
          {
            type: 'metric',
            title: 'Memory Utilization',
            metrics: ['MemoryUtilization']
          }
        ]
      },
      {
        name: 'Application Performance',
        widgets: [
          {
            type: 'metric',
            title: 'Response Time',
            metrics: ['ResponseTime']
          },
          {
            type: 'metric',
            title: 'Error Rate',
            metrics: ['ErrorRate']
          }
        ]
      }
    ];

    const config = {
      dashboards,
      refreshInterval: 300,
      timeRange: '1h'
    };

    console.log('âœ… ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¾ã—ãŸ');
    return config;
  }

  // ãƒ­ã‚®ãƒ³ã‚°ã®è¨­å®š
  async setupLogging() {
    console.log('ğŸ“ ãƒ­ã‚®ãƒ³ã‚°ã‚’è¨­å®šã—ã¾ã™...');

    // ãƒ­ã‚°åé›†ã®è¨­å®š
    const logCollection = await this.configureLogCollection();

    // ãƒ­ã‚°åˆ†æã®è¨­å®š
    const logAnalysis = await this.configureLogAnalysis();

    // ãƒ­ã‚°ä¿æŒãƒãƒªã‚·ãƒ¼ã®è¨­å®š
    const retention = await this.configureLogRetention();

    return {
      collection: logCollection,
      analysis: logAnalysis,
      retention
    };
  }

  // ãƒ­ã‚°åé›†ã®è¨­å®š
  async configureLogCollection() {
    console.log('ğŸ“¥ ãƒ­ã‚°åé›†ã‚’è¨­å®šã—ã¾ã™...');

    const sources = [
      {
        name: 'application',
        path: '/var/log/application/*.log',
        format: 'json'
      },
      {
        name: 'nginx',
        path: '/var/log/nginx/*.log',
        format: 'combined'
      },
      {
        name: 'system',
        path: '/var/log/syslog',
        format: 'syslog'
      }
    ];

    const config = {
      enabled: true,
      sources,
      shipper: 'fluentd',
      buffer: {
        size: '100MB',
        flushInterval: 5
      }
    };

    console.log('âœ… ãƒ­ã‚°åé›†ã‚’è¨­å®šã—ã¾ã—ãŸ');
    return config;
  }

  // ãƒ­ã‚°åˆ†æã®è¨­å®š
  async configureLogAnalysis() {
    console.log('ğŸ” ãƒ­ã‚°åˆ†æã‚’è¨­å®šã—ã¾ã™...');

    const pipelines = [
      {
        name: 'error-detection',
        filters: [
          { field: 'level', operator: 'equals', value: 'ERROR' }
        ],
        actions: ['alert', 'aggregate']
      },
      {
        name: 'performance-analysis',
        filters: [
          { field: 'response_time', operator: 'greater_than', value: 1000 }
        ],
        actions: ['aggregate', 'dashboard']
      },
      {
        name: 'security-audit',
        filters: [
          { field: 'event_type', operator: 'equals', value: 'auth_failure' }
        ],
        actions: ['alert', 'correlate']
      }
    ];

    const config = {
      enabled: true,
      pipelines,
      retention: {
        hot: '7d',
        warm: '30d',
        cold: '90d'
      }
    };

    console.log('âœ… ãƒ­ã‚°åˆ†æã‚’è¨­å®šã—ã¾ã—ãŸ');
    return config;
  }

  // ãƒ­ã‚°ä¿æŒãƒãƒªã‚·ãƒ¼ã®è¨­å®š
  async configureLogRetention() {
    console.log('ğŸ’¾ ãƒ­ã‚°ä¿æŒãƒãƒªã‚·ãƒ¼ã‚’è¨­å®šã—ã¾ã™...');

    const policies = [
      {
        name: 'application-logs',
        pattern: 'application-*',
        retention: '90d',
        archive: true
      },
      {
        name: 'access-logs',
        pattern: 'access-*',
        retention: '365d',
        archive: true
      },
      {
        name: 'system-logs',
        pattern: 'system-*',
        retention: '30d',
        archive: false
      }
    ];

    const config = {
      policies,
      compression: 'gzip',
      storage: 's3',
      lifecycle: {
        transitionToIA: '30d',
        transitionToGlacier: '90d',
        expiration: '365d'
      }
    };

    console.log('âœ… ãƒ­ã‚°ä¿æŒãƒãƒªã‚·ãƒ¼ã‚’è¨­å®šã—ã¾ã—ãŸ');
    return config;
  }

  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®è¨­å®š
  async setupSecurity() {
    console.log('ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è¨­å®šã—ã¾ã™...');

    // ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã¨ã‚¢ã‚¯ã‚»ã‚¹ç®¡ç†
    const iam = await this.configureIAM();

    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
    const network = await this.configureNetworkSecurity();

    // ãƒ‡ãƒ¼ã‚¿ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
    const data = await this.configureDataSecurity();

    // ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯
    const compliance = await this.configureCompliance();

    return {
      iam,
      network,
      data,
      compliance
    };
  }

  // IAMã®è¨­å®š
  async configureIAM() {
    console.log('ğŸ‘¤ IAMã‚’è¨­å®šã—ã¾ã™...');

    const roles = [
      {
        name: 'EC2InstanceRole',
        policies: ['AmazonSSMManagedInstanceCore', 'CloudWatchAgentServerPolicy']
      },
      {
        name: 'LambdaExecutionRole',
        policies: ['AWSLambdaBasicExecutionRole']
      }
    ];

    const policies = [
      {
        name: 'CustomApplicationPolicy',
        statements: [
          {
            Effect: 'Allow',
            Action: ['logs:*', 'cloudwatch:*'],
            Resource: '*'
          }
        ]
      }
    ];

    const config = {
      roles,
      policies,
      mfa: true,
      passwordPolicy: {
        minLength: 12,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSymbols: true
      }
    };

    console.log('âœ… IAMã‚’è¨­å®šã—ã¾ã—ãŸ');
    return config;
  }

  // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®è¨­å®š
  async configureNetworkSecurity() {
    console.log('ğŸŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è¨­å®šã—ã¾ã™...');

    const securityGroups = [
      {
        name: 'web-sg',
        description: 'Security group for web servers',
        rules: [
          {
            protocol: 'tcp',
            fromPort: 80,
            toPort: 80,
            cidr: '0.0.0.0/0'
          },
          {
            protocol: 'tcp',
            fromPort: 443,
            toPort: 443,
            cidr: '0.0.0.0/0'
          }
        ]
      },
      {
        name: 'app-sg',
        description: 'Security group for application servers',
        rules: [
          {
            protocol: 'tcp',
            fromPort: 8080,
            toPort: 8080,
            source: 'web-sg'
          }
        ]
      }
    ];

    const nacls = [
      {
        name: 'public-nacl',
        entries: [
          { ruleNumber: 100, action: 'allow', cidr: '0.0.0.0/0' }
        ]
      }
    ];

    const config = {
      securityGroups,
      nacls,
      waf: true,
      ddosProtection: true
    };

    console.log('âœ… ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è¨­å®šã—ã¾ã—ãŸ');
    return config;
  }

  // ãƒ‡ãƒ¼ã‚¿ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®è¨­å®š
  async configureDataSecurity() {
    console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è¨­å®šã—ã¾ã™...');

    const encryption = {
      atRest: true,
      inTransit: true,
      keyRotation: true,
      algorithm: 'AES-256'
    };

    const backup = {
      enabled: true,
      frequency: 'daily',
      retention: '30d',
      encryption: true
    };

    const accessControl = {
      principleOfLeastPrivilege: true,
      auditLogging: true,
      sessionTimeout: 3600
    };

    const config = {
      encryption,
      backup,
      accessControl
    };

    console.log('âœ… ãƒ‡ãƒ¼ã‚¿ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è¨­å®šã—ã¾ã—ãŸ');
    return config;
  }

  // ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã®è¨­å®š
  async configureCompliance() {
    console.log('ğŸ“‹ ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’è¨­å®šã—ã¾ã™...');

    const standards = [
      {
        name: 'PCI DSS',
        enabled: true,
        controls: ['encryption', 'access_control', 'audit_logging']
      },
      {
        name: 'SOC 2',
        enabled: true,
        controls: ['security', 'availability', 'confidentiality']
      },
      {
        name: 'GDPR',
        enabled: true,
        controls: ['data_protection', 'consent_management', 'right_to_be_forgotten']
      }
    ];

    const audits = {
      frequency: 'quarterly',
      automated: true,
      reporting: true
    };

    const config = {
      standards,
      audits,
      remediation: {
        autoRemediate: true,
        severityThreshold: 'medium'
      }
    };

    console.log('âœ… ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã‚’è¨­å®šã—ã¾ã—ãŸ');
    return config;
  }

  // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®è¨­å®š
  async setupBackup() {
    console.log('ğŸ’¾ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’è¨­å®šã—ã¾ã™...');

    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨ˆç”»ã®ä½œæˆ
    const backupPlan = await this.createBackupPlan();

    // å¾©å…ƒè¨ˆç”»ã®ä½œæˆ
    const recoveryPlan = await this.createRecoveryPlan();

    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®æ¤œè¨¼
    const validation = await this.validateBackupConfiguration(backupPlan);

    return {
      plan: backupPlan,
      recovery: recoveryPlan,
      validation
    };
  }

  // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨ˆç”»ã®ä½œæˆ
  async createBackupPlan() {
    console.log('ğŸ“… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨ˆç”»ã‚’ä½œæˆã—ã¾ã™...');

    const resources = [
      {
        type: 'database',
        name: 'main-db',
        frequency: 'daily',
        retention: '30d',
        compression: true,
        encryption: true
      },
      {
        type: 'filesystem',
        name: 'application-data',
        frequency: 'daily',
        retention: '7d',
        compression: true,
        encryption: true
      },
      {
        type: 'configuration',
        name: 'app-config',
        frequency: 'weekly',
        retention: '90d',
        compression: true,
        encryption: true
      }
    ];

    const schedule = {
      timezone: 'UTC',
      maintenanceWindow: '02:00-04:00'
    };

    const config = {
      resources,
      schedule,
      storage: {
        type: 's3',
        redundancy: 'multi-az',
        lifecycle: {
          transitionToIA: '30d',
          transitionToGlacier: '90d',
          expiration: '365d'
        }
      }
    };

    console.log('âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨ˆç”»ã‚’ä½œæˆã—ã¾ã—ãŸ');
    return config;
  }

  // å¾©å…ƒè¨ˆç”»ã®ä½œæˆ
  async createRecoveryPlan() {
    console.log('ğŸ”„ å¾©å…ƒè¨ˆç”»ã‚’ä½œæˆã—ã¾ã™...');

    const scenarios = [
      {
        name: 'database-failure',
        rto: '15m',
        rpo: '5m',
        steps: [
          'Identify failure',
          'Restore from latest backup',
          'Validate data integrity',
          'Update DNS records'
        ]
      },
      {
        name: 'region-failure',
        rto: '4h',
        rpo: '1h',
        steps: [
          'Activate DR region',
          'Promote standby database',
          'Update traffic routing',
          'Validate service availability'
        ]
      }
    ];

    const config = {
      scenarios,
      testing: {
        frequency: 'quarterly',
        automated: true
      },
      documentation: {
        runbooks: true,
        contactList: true
      }
    };

    console.log('âœ… å¾©å…ƒè¨ˆç”»ã‚’ä½œæˆã—ã¾ã—ãŸ');
    return config;
  }

  // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®šã®æ¤œè¨¼
  async validateBackupConfiguration(backupPlan) {
    console.log('ğŸ” ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®šã‚’æ¤œè¨¼ã—ã¾ã™...');

    const validation = {
      status: 'valid',
      checks: [],
      issues: [],
      recommendations: []
    };

    // å„ãƒªã‚½ãƒ¼ã‚¹ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®šã‚’æ¤œè¨¼
    for (const resource of backupPlan.resources) {
      const check = await this.validateBackupResource(resource);
      validation.checks.push(check);

      if (!check.valid) {
        validation.issues.push(...check.issues);
      }
    }

    // RTO/RPOã®æ¤œè¨¼
    const rtoRpoCheck = this.validateRtoRpo(backupPlan);
    validation.checks.push(rtoRpoCheck);

    if (!rtoRpoCheck.valid) {
      validation.issues.push(...rtoRpoCheck.issues);
    }

    // å…¨ä½“ã®å¥å…¨æ€§åˆ¤å®š
    const invalidChecks = validation.checks.filter(c => !c.valid);
    if (invalidChecks.length > 0) {
      validation.status = 'invalid';
    }

    // æ¨å¥¨äº‹é …ã®ç”Ÿæˆ
    validation.recommendations = this.generateBackupRecommendations(validation);

    console.log(`âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®šã®æ¤œè¨¼ãŒå®Œäº†ã—ã¾ã—ãŸ: ${validation.status}`);
    return validation;
  }

  // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒªã‚½ãƒ¼ã‚¹ã®æ¤œè¨¼
  async validateBackupResource(resource) {
    const check = {
      resource: resource.name,
      valid: true,
      issues: []
    };

    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—é »åº¦ã®æ¤œè¨¼
    if (!resource.frequency) {
      check.valid = false;
      check.issues.push('Backup frequency not specified');
    }

    // ä¿æŒæœŸé–“ã®æ¤œè¨¼
    if (!resource.retention) {
      check.valid = false;
      check.issues.push('Retention period not specified');
    }

    // æš—å·åŒ–ã®æ¤œè¨¼
    if (!resource.encryption) {
      check.valid = false;
      check.issues.push('Encryption not enabled');
    }

    return check;
  }

  // RTO/RPOã®æ¤œè¨¼
  validateRtoRpo(backupPlan) {
    const check = {
      type: 'RTO/RPO',
      valid: true,
      issues: []
    };

    // å®Ÿéš›ã®RTO/RPOæ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    // ã“ã“ã§ã¯ç°¡æ˜“çš„ãªãƒã‚§ãƒƒã‚¯
    const hasAdequateBackup = backupPlan.resources.some(r =>
      r.type === 'database' && r.frequency === 'daily'
    );

    if (!hasAdequateBackup) {
      check.valid = false;
      check.issues.push('Inadequate backup frequency for RPO requirements');
    }

    return check;
  }

  // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ¨å¥¨äº‹é …ã®ç”Ÿæˆ
  generateBackupRecommendations(validation) {
    const recommendations = [];

    if (validation.issues.some(issue => issue.includes('frequency'))) {
      recommendations.push('Consider increasing backup frequency for critical resources');
    }

    if (validation.issues.some(issue => issue.includes('encryption'))) {
      recommendations.push('Enable encryption for all backup resources');
    }

    if (validation.issues.some(issue => issue.includes('retention'))) {
      recommendations.push('Define appropriate retention policies for compliance');
    }

    return recommendations;
  }

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
  generateDeploymentId() {
    return `deployment_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
  }

  generateResourceId() {
    return `res_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
  }
}

// è£œåŠ©ã‚¯ãƒ©ã‚¹
class InfrastructureManager {
  constructor(config) {
    this.config = config;
  }

  // ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ç®¡ç†ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…
}

class MonitoringService {
  constructor(config) {
    this.config = config;
  }

  // ç›£è¦–ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…
}

class LoggingService {
  constructor(config) {
    this.config = config;
  }

  // ãƒ­ã‚®ãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…
}

class SecurityService {
  constructor(config) {
    this.config = config;
  }

  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…
}

class BackupService {
  constructor(config) {
    this.config = config;
  }

  // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…
}

module.exports = { DevOpsToolchain };
```

:::

## ã¾ã¨ã‚

ã“ã®ãƒšãƒ¼ã‚¸ã§ã¯ã€Claude Codeã‚’æ´»ç”¨ã—ãŸé«˜åº¦ãªæŠ€è¡“ã¨ãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«ã¤ã„ã¦å­¦ã³ã¾ã—ãŸã€‚ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã€DevOpsãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ãªã©ã€ç¾ä»£ã®ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢é–‹ç™ºã§å¿…é ˆã¨ãªã‚‹æŠ€è¡“ã‚’ä½“ç³»çš„ã«è§£èª¬ã—ã¾ã—ãŸã€‚

:::note è¦ç‚¹ã®ã¾ã¨ã‚

- ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ãªã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰
- CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã‚’è‡ªå‹•åŒ–ãƒ»åŠ¹ç‡åŒ–
- DevOpsãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã§é–‹ç™ºã¨é‹ç”¨ã®å”æ¥­ã‚’ä¿ƒé€²
- Claude Codeã‚’æ´»ç”¨ã—ãŸè‡ªå‹•åŒ–ã§è¤‡é›‘ãªè¨­å®šã‚’ç°¡ç´ åŒ–
- ç›£è¦–ã€ãƒ­ã‚®ãƒ³ã‚°ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®åŒ…æ‹¬çš„ãªçµ±åˆ
- è‡ªå‹•ãƒ†ã‚¹ãƒˆã¨å“è³ªã‚²ãƒ¼ãƒˆã§ãƒªãƒªãƒ¼ã‚¹å“è³ªã‚’ä¿è¨¼

:::

## é–¢é€£è¨˜äº‹

[ãƒãƒ¼ãƒ é–‹ç™ºã®åŸºç¤](../team-development-basics/team-development-basics.md)
[ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã¨Git](../version-control/version-control.md)
[ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„](../coding-standards/coding-standards.md)
[å®Ÿè·µçš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼](../practical-workflows/practical-workflows.md)