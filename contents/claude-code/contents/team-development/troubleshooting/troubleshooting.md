---
title: "ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°"
description: "Claude Codeã‚’æ´»ç”¨ã—ãŸãƒãƒ¼ãƒ é–‹ç™ºã«ãŠã‘ã‚‹ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®å®Ÿè·µçš„ãªæ‰‹æ³•ã‚’å­¦ã³ã¾ã™ã€‚ä¸€èˆ¬çš„ãªå•é¡Œã®è§£æ±ºç­–ã¨äºˆé˜²ç­–ã‚’ãƒã‚¹ã‚¿ãƒ¼ã—ã¾ã™ã€‚"
status: "published"
priority: "high"
tags: ["ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°", "å•é¡Œè§£æ±º", "ãƒ‡ãƒãƒƒã‚°", "äºˆé˜²ç­–"]
author: "Claude"
category: "team-development"
---

# ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

Claude Codeã‚’æ´»ç”¨ã—ãŸãƒãƒ¼ãƒ é–‹ç™ºã«ãŠã‘ã‚‹ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®å®Ÿè·µçš„ãªã‚¬ã‚¤ãƒ‰ã§ã™ã€‚ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã§ç™ºç”Ÿã™ã‚‹ä¸€èˆ¬çš„ãªå•é¡Œã®ç‰¹å®šã€è§£æ±ºã€ãã—ã¦äºˆé˜²ã®ãŸã‚ã®ä½“ç³»çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’å­¦ã³ã¾ã™ã€‚

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®é‡è¦æ€§

ãƒãƒ¼ãƒ é–‹ç™ºã§ã¯ã€æŠ€è¡“çš„ãªå•é¡Œã ã‘ã§ãªãã€ãƒ—ãƒ­ã‚»ã‚¹ã‚„ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«é–¢ã™ã‚‹å•é¡Œã‚‚é »ç¹ã«ç™ºç”Ÿã—ã¾ã™ã€‚åŠ¹æœçš„ãªãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¹ã‚­ãƒ«ã¯ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æˆåŠŸã«ä¸å¯æ¬ ã§ã™ã€‚

:::note ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãŒå¿…è¦ãªç†ç”±

- **é–‹ç™ºåŠ¹ç‡ã®ç¶­æŒ**: å•é¡ŒãŒç™ºç”Ÿã—ãŸéš›ã®è¿…é€Ÿãªè§£æ±ºã§é–‹ç™ºé…å»¶ã‚’é˜²æ­¢
- **å“è³ªã®ç¢ºä¿**: å•é¡Œã®æ ¹æœ¬åŸå› ã‚’ç‰¹å®šã—ã€å†ç™ºã‚’é˜²æ­¢
- **ãƒãƒ¼ãƒ ã®ä¿¡é ¼æ€§**: ä¸€è²«ã—ãŸå•é¡Œè§£æ±ºèƒ½åŠ›ã§ã‚¹ãƒ†ãƒ¼ã‚¯ãƒ›ãƒ«ãƒ€ãƒ¼ã®ä¿¡é ¼ã‚’ç²å¾—
- **å­¦ç¿’ã®ä¿ƒé€²**: å•é¡Œè§£æ±ºãƒ—ãƒ­ã‚»ã‚¹ã‚’é€šã˜ã¦ãƒãƒ¼ãƒ å…¨ä½“ã®æŠ€è¡“åŠ›å‘ä¸Š
- **äºˆé˜²çš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ**: å•é¡Œç™ºç”Ÿå‰ã®äºˆé˜²ç­–ã§ãƒªã‚¹ã‚¯ã‚’ä½æ¸›

:::

## ä½“ç³»çš„ãªå•é¡Œè§£æ±ºã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

### å•é¡Œè§£æ±ºã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯

:::step

1. ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ç’°å¢ƒã®æ§‹ç¯‰

ä»»æ„ã®å ´æ‰€ï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ãªã©ï¼‰ã§`troubleshooting-practice`ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆã—ã€å®Ÿè·µã‚’å§‹ã‚ã¾ã™ã€‚

```bash
mkdir troubleshooting-practice
cd troubleshooting-practice
npm init -y
```

2. å•é¡Œè§£æ±ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®å®Ÿè£…

`src/troubleshooting-framework.js`ã‚’ä½œæˆã—ã€Claude Codeã‚’æ´»ç”¨ã—ãŸå•é¡Œè§£æ±ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

_src/troubleshooting-framework.js_

```javascript
/**
 * Claude Codeã‚’æ´»ç”¨ã—ãŸãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
 * ä½“ç³»çš„ãªå•é¡Œè§£æ±ºã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’æä¾›
 */
class TroubleshootingFramework {
  constructor() {
    this.problemHistory = [];
    this.solutions = new Map();
    this.patterns = new Map();
    this.metrics = {
      totalProblems: 0,
      resolvedProblems: 0,
      averageResolutionTime: 0,
      commonProblems: new Map()
    };
  }

  // å•é¡Œã®å ±å‘Šã¨åˆ†æ
  async reportProblem(problemData) {
    const problem = {
      id: this.generateId(),
      title: problemData.title,
      description: problemData.description,
      category: problemData.category || 'general',
      severity: problemData.severity || 'medium',
      environment: problemData.environment || {},
      reproductions: problemData.reproductions || [],
      reportedBy: problemData.reportedBy,
      reportedAt: new Date(),
      status: 'open',
      analysis: null,
      solutions: [],
      rootCause: null
    };

    // å•é¡Œã®è‡ªå‹•åˆ†æ
    problem.analysis = await this.analyzeProblem(problem);

    // é¡ä¼¼å•é¡Œã®æ¤œç´¢
    const similarProblems = this.findSimilarProblems(problem);
    problem.similarProblems = similarProblems;

    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®æ›´æ–°
    this.updateMetrics(problem);

    // å•é¡Œå±¥æ­´ã«è¿½åŠ 
    this.problemHistory.push(problem);

    console.log(`ğŸ” å•é¡Œã‚’å ±å‘Šã—ã¾ã—ãŸ: ${problem.title} (${problem.id})`);
    console.log(`ğŸ“Š è‡ªå‹•åˆ†æçµæœ: ${problem.analysis.confidence}ã®ç¢ºä¿¡åº¦`);

    return problem;
  }

  // å•é¡Œã®åˆ†æ
  async analyzeProblem(problem) {
    const analysis = {
      confidence: 0,
      possibleCauses: [],
      recommendedActions: [],
      estimatedComplexity: 'medium',
      requiredSkills: [],
      impact: {
        users: 0,
        systems: [],
        business: 'low'
      }
    };

    // Claude Codeã«ã‚ˆã‚‹å•é¡Œåˆ†æ
    const claudeAnalysis = await this.analyzeWithClaudeCode(problem);
    analysis.possibleCauses = claudeAnalysis.causes || [];
    analysis.recommendedActions = claudeAnalysis.actions || [];
    analysis.confidence = claudeAnalysis.confidence || 0.5;

    // å½±éŸ¿åº¦ã®è©•ä¾¡
    analysis.impact = this.assessImpact(problem);

    // å¿…è¦ãªã‚¹ã‚­ãƒ«ã®ç‰¹å®š
    analysis.requiredSkills = this.identifyRequiredSkills(analysis.possibleCauses);

    // è¤‡é›‘æ€§ã®è¦‹ç©ã‚‚ã‚Š
    analysis.estimatedComplexity = this.estimateComplexity(analysis);

    return analysis;
  }

  // æ ¹æœ¬åŸå› ã®åˆ†æ
  async performRootCauseAnalysis(problemId) {
    const problem = this.problemHistory.find(p => p.id === problemId);
    if (!problem) {
      throw new Error('å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    console.log(`ğŸ” æ ¹æœ¬åŸå› åˆ†æã‚’é–‹å§‹: ${problem.title}`);

    // 5 Whysæ‰‹æ³•ã®é©ç”¨
    const rootCause = await this.applyFiveWhys(problem);

    // é­šéª¨å›³åˆ†æ
    const fishboneAnalysis = await this.performFishboneAnalysis(problem);

    // ã‚·ã‚¹ãƒ†ãƒ æ€è€ƒã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
    const systemsAnalysis = await this.analyzeSystemInteractions(problem);

    problem.rootCause = {
      primary: rootCause.primaryCause,
      contributingFactors: rootCause.contributingFactors,
      fishboneCategories: fishboneAnalysis,
      systemInteractions: systemsAnalysis,
      analysisDate: new Date(),
      analyst: 'AI Assistant'
    };

    return problem.rootCause;
  }

  // è§£æ±ºç­–ã®ç”Ÿæˆã¨å®Ÿè£…
  async generateSolutions(problemId) {
    const problem = this.problemHistory.find(p => p.id === problemId);
    if (!problem) {
      throw new Error('å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    console.log(`ğŸ’¡ è§£æ±ºç­–ã‚’ç”Ÿæˆä¸­: ${problem.title}`);

    // Claude Codeã«ã‚ˆã‚‹è§£æ±ºç­–ã®ç”Ÿæˆ
    const solutions = await this.generateSolutionsWithClaudeCode(problem);

    // å„è§£æ±ºç­–ã®è©•ä¾¡
    const evaluatedSolutions = await this.evaluateSolutions(problem, solutions);

    // æœ€é©ãªè§£æ±ºç­–ã®é¸å®š
    const recommendedSolution = this.selectOptimalSolution(evaluatedSolutions);

    problem.solutions = evaluatedSolutions;
    problem.recommendedSolution = recommendedSolution;

    return {
      solutions: evaluatedSolutions,
      recommendation: recommendedSolution
    };
  }

  // è§£æ±ºç­–ã®å®Ÿè£…ã¨æ¤œè¨¼
  async implementSolution(problemId, solutionId, implementation) {
    const problem = this.problemHistory.find(p => p.id === problemId);
    if (!problem) {
      throw new Error('å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    const solution = problem.solutions.find(s => s.id === solutionId);
    if (!solution) {
      throw new Error('è§£æ±ºç­–ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    console.log(`ğŸ”§ è§£æ±ºç­–ã‚’å®Ÿè£…ä¸­: ${solution.title}`);

    // å®Ÿè£…ãƒ—ãƒ©ãƒ³ã®ä½œæˆ
    const implementationPlan = await this.createImplementationPlan(solution, implementation);

    // å®‰å…¨æªç½®ã®å®Ÿæ–½
    const safetyMeasures = await this.implementSafetyMeasures(problem, solution);

    // è§£æ±ºç­–ã®é©ç”¨
    const implementationResult = await this.applySolution(solution, implementationPlan);

    // æ¤œè¨¼ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
    const verification = await this.verifySolution(problem, solution, implementationResult);

    // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æ›´æ–°
    await this.updateDocumentation(problem, solution, implementationResult);

    // å•é¡Œã®ã‚¯ãƒ­ãƒ¼ã‚º
    problem.status = 'resolved';
    problem.resolvedAt = new Date();
    problem.resolution = {
      solutionId: solutionId,
      implementation: implementationResult,
      verification,
      resolvedBy: implementation.implementedBy
    };

    console.log(`âœ… å•é¡Œã‚’è§£æ±ºã—ã¾ã—ãŸ: ${problem.title}`);

    return {
      success: verification.success,
      implementation: implementationResult,
      verification
    };
  }

  // äºˆé˜²ç­–ã®å®Ÿè£…
  async implementPreventiveMeasures(problemId) {
    const problem = this.problemHistory.find(p => p.id === problemId);
    if (!problem || !problem.rootCause) {
      throw new Error('å•é¡Œã¾ãŸã¯æ ¹æœ¬åŸå› åˆ†æãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    console.log(`ğŸ›¡ï¸  äºˆé˜²ç­–ã‚’å®Ÿè£…ä¸­: ${problem.title}`);

    const preventiveMeasures = [];

    // ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ™ãƒ«ã®äºˆé˜²ç­–
    if (problem.category === 'code') {
      const codeMeasures = await this.generateCodePreventiveMeasures(problem);
      preventiveMeasures.push(...codeMeasures);
    }

    // ãƒ—ãƒ­ã‚»ã‚¹ãƒ¬ãƒ™ãƒ«ã®äºˆé˜²ç­–
    if (problem.category === 'process') {
      const processMeasures = await this.generateProcessPreventiveMeasures(problem);
      preventiveMeasures.push(...processMeasures);
    }

    // ç›£è¦–ã¨ã‚¢ãƒ©ãƒ¼ãƒˆã®è¨­å®š
    const monitoringMeasures = await this.setupMonitoring(problem);
    preventiveMeasures.push(...monitoringMeasures);

    // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°
    const documentationMeasures = await this.createPreventiveDocumentation(problem);
    preventiveMeasures.push(...documentationMeasures);

    problem.preventiveMeasures = preventiveMeasures;

    console.log(`âœ… äºˆé˜²ç­–ã‚’å®Ÿè£…ã—ã¾ã—ãŸ: ${preventiveMeasures.length}ä»¶`);

    return preventiveMeasures;
  }

  // Claude Codeã«ã‚ˆã‚‹å•é¡Œåˆ†æ
  async analyzeWithClaudeCode(problem) {
    const prompt = `
ä»¥ä¸‹ã®å•é¡Œã‚’åˆ†æã—ã¦ãã ã•ã„:

å•é¡Œã‚¿ã‚¤ãƒˆãƒ«: ${problem.title}
å•é¡Œèª¬æ˜: ${problem.description}
ã‚«ãƒ†ã‚´ãƒªãƒ¼: ${problem.category}
æ·±åˆ»åº¦: ${problem.severity}
ç’°å¢ƒ: ${JSON.stringify(problem.environment, null, 2)}

åˆ†æã®è¦³ç‚¹:
1. è€ƒãˆã‚‰ã‚Œã‚‹åŸå› ã®ç‰¹å®š
2. å•é¡Œã®å½±éŸ¿ç¯„å›²ã®è©•ä¾¡
3. è§£æ±ºã«å¿…è¦ãªã‚¹ã‚­ãƒ«
4. æ¨å¥¨ã•ã‚Œã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
5. é¡ä¼¼ã®éå»äº‹ä¾‹ã‹ã‚‰ã®å­¦ã³

å½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„:
- causes: [åŸå› 1, åŸå› 2, ...]
- actions: [ã‚¢ã‚¯ã‚·ãƒ§ãƒ³1, ã‚¢ã‚¯ã‚·ãƒ§ãƒ³2, ...]
- confidence: 0.0ã€œ1.0ã®ç¢ºä¿¡åº¦
- requiredSkills: [ã‚¹ã‚­ãƒ«1, ã‚¹ã‚­ãƒ«2, ...]
`;

    // å®Ÿéš›ã®Claude Code APIå‘¼ã³å‡ºã—ï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    return {
      causes: [
        'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®å•é¡Œ',
        'è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª¤ã‚Š',
        'ä¾å­˜é–¢ä¿‚ã®ç«¶åˆ'
      ],
      actions: [
        'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®ç¢ºèª',
        'è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œè¨¼',
        'ä¾å­˜é–¢ä¿‚ã®å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«'
      ],
      confidence: 0.8,
      requiredSkills: ['ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯', 'è¨­å®šç®¡ç†', 'ãƒ‡ãƒãƒƒã‚°']
    };
  }

  // 5 Whysæ‰‹æ³•ã®é©ç”¨
  async applyFiveWhys(problem) {
    console.log('ğŸ¤” 5 Whysã§æ ¹æœ¬åŸå› ã‚’åˆ†æã—ã¾ã™...');

    const whys = [];
    let currentQuestion = `ãªãœã€Œ${problem.description}ã€ãŒç™ºç”Ÿã—ãŸã®ã‹ï¼Ÿ`;

    for (let i = 0; i < 5; i++) {
      const answer = await this.askWhy(currentQuestion, problem);
      whys.push({
        question: currentQuestion,
        answer: answer,
        level: i + 1
      });

      if (i < 4) {
        currentQuestion = `ãªãœã€Œ${answer}ã€ãŒç™ºç”Ÿã—ãŸã®ã‹ï¼Ÿ`;
      }
    }

    const primaryCause = whys[whys.length - 1].answer;
    const contributingFactors = whys.slice(0, -1).map(w => w.answer);

    return {
      primaryCause,
      contributingFactors,
      analysisChain: whys
    };
  }

  // é­šéª¨å›³åˆ†æ
  async performFishboneAnalysis(problem) {
    const categories = {
      äººé–“: ['ã‚¹ã‚­ãƒ«ä¸è¶³', 'ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ä¸è¶³', 'ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä¸è¶³'],
      æ–¹æ³•: ['ãƒ—ãƒ­ã‚»ã‚¹ã®æ¬ å¦‚', 'æ‰‹é †ã®ä¸å‚™', 'ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹é•å'],
      æ©Ÿæ¢°: ['ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢éšœå®³', 'ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ãƒã‚°', 'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œ'],
      ææ–™: ['ãƒ‡ãƒ¼ã‚¿ã®ä¸æ•´åˆ', 'å¤–éƒ¨APIã®å•é¡Œ', 'è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª¤ã‚Š'],
      æ¸¬å®š: ['ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ä¸è¶³', 'ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®èª¤ã‚Š', 'ãƒ­ã‚°ã®ä¸ååˆ†'],
      ç’°å¢ƒ: ['ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å•é¡Œ', 'ã‚µãƒ¼ãƒãƒ¼ç’°å¢ƒ', 'å¤–éƒ¨è¦å› ']
    };

    const analysis = {};

    for (const [category, causes] of Object.entries(categories)) {
      const relevantCauses = await this.identifyRelevantCauses(problem, causes);
      if (relevantCauses.length > 0) {
        analysis[category] = relevantCauses;
      }
    }

    return analysis;
  }

  // ã‚·ã‚¹ãƒ†ãƒ æ€è€ƒã«ã‚ˆã‚‹åˆ†æ
  async analyzeSystemInteractions(problem) {
    const interactions = {
      components: [],
      dataFlow: [],
      dependencies: [],
      externalSystems: []
    };

    // å®Ÿéš›ã®ã‚·ã‚¹ãƒ†ãƒ åˆ†æãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    // ã“ã“ã§ã¯ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
    return interactions;
  }

  // Claude Codeã«ã‚ˆã‚‹è§£æ±ºç­–ã®ç”Ÿæˆ
  async generateSolutionsWithClaudeCode(problem) {
    const prompt = `
ä»¥ä¸‹ã®å•é¡Œã«å¯¾ã™ã‚‹è§£æ±ºç­–ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„:

å•é¡Œ: ${problem.title}
èª¬æ˜: ${problem.description}
åŸå› åˆ†æ: ${JSON.stringify(problem.rootCause, null, 2)}
å½±éŸ¿: ${JSON.stringify(problem.analysis.impact, null, 2)}

è§£æ±ºç­–ã®è¦ä»¶:
1. æ ¹æœ¬åŸå› ã‚’è§£æ±ºã™ã‚‹ã“ã¨
2. å®Ÿè£…ã®è¤‡é›‘ã•ã‚’è€ƒæ…®ã™ã‚‹ã“ã¨
3. å‰¯ä½œç”¨ã®ãƒªã‚¹ã‚¯ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨
4. ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§ã‚’ç¢ºä¿ã™ã‚‹ã“ã¨
5. é•·æœŸçš„ãªä¿å®ˆæ€§ã‚’è€ƒæ…®ã™ã‚‹ã“ã¨

å„è§£æ±ºç­–ã«ã¤ã„ã¦ä»¥ä¸‹ã®æƒ…å ±ã‚’æä¾›ã—ã¦ãã ã•ã„:
- title: è§£æ±ºç­–ã®ã‚¿ã‚¤ãƒˆãƒ«
- description: è©³ç´°ãªèª¬æ˜
- complexity: å®Ÿè£…ã®è¤‡é›‘ã• (low/medium/high)
- risk: ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ« (low/medium/high)
- timeframe: å®Ÿè£…æœŸé–“ã®è¦‹ç©ã‚‚ã‚Š
- sideEffects: è€ƒãˆã‚‰ã‚Œã‚‹å‰¯ä½œç”¨
- testing: å¿…è¦ãªãƒ†ã‚¹ãƒˆ
`;

    // å®Ÿéš›ã®Claude Code APIå‘¼ã³å‡ºã—ï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
    return [
      {
        id: this.generateId(),
        title: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®æ”¹å–„',
        description: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®šã‚’æœ€é©åŒ–ã—ã€å†æ¥ç¶šãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’å®Ÿè£…',
        complexity: 'medium',
        risk: 'low',
        timeframe: '2-3æ—¥',
        sideEffects: ['æ—¢å­˜ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®šã«å½±éŸ¿ã™ã‚‹å¯èƒ½æ€§'],
        testing: ['æ¥ç¶šãƒ†ã‚¹ãƒˆ', 'è² è·ãƒ†ã‚¹ãƒˆ', 'ãƒ•ã‚§ã‚¤ãƒ«ã‚ªãƒ¼ãƒãƒ¼ãƒ†ã‚¹ãƒˆ'],
        effectiveness: 0.9
      },
      {
        id: this.generateId(),
        title: 'ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®å¼·åŒ–',
        description: 'åŒ…æ‹¬çš„ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…',
        complexity: 'low',
        risk: 'low',
        timeframe: '1-2æ—¥',
        sideEffects: ['ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å¤‰æ›´ãŒå¿…è¦'],
        testing: ['ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã®ãƒ†ã‚¹ãƒˆ', 'ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆ'],
        effectiveness: 0.8
      }
    ];
  }

  // è§£æ±ºç­–ã®è©•ä¾¡
  async evaluateSolutions(problem, solutions) {
    const evaluatedSolutions = [];

    for (const solution of solutions) {
      const evaluation = {
        ...solution,
        scores: {
          effectiveness: this.evaluateEffectiveness(solution),
          feasibility: this.evaluateFeasibility(solution),
          risk: this.evaluateRisk(solution),
          cost: this.evaluateCost(solution)
        },
        overallScore: 0
      };

      // ç·åˆã‚¹ã‚³ã‚¢ã®è¨ˆç®—
      evaluation.overallScore = (
        evaluation.scores.effectiveness * 0.3 +
        evaluation.scores.feasibility * 0.25 +
        evaluation.scores.risk * 0.25 +
        evaluation.scores.cost * 0.2
      );

      evaluatedSolutions.push(evaluation);
    }

    // ã‚¹ã‚³ã‚¢ã§ã‚½ãƒ¼ãƒˆ
    return evaluatedSolutions.sort((a, b) => b.overallScore - a.overallScore);
  }

  // æœ€é©ãªè§£æ±ºç­–ã®é¸å®š
  selectOptimalSolution(solutions) {
    return solutions[0]; // ã‚¹ã‚³ã‚¢ãŒæœ€ã‚‚é«˜ã„è§£æ±ºç­–
  }

  // å½±éŸ¿åº¦ã®è©•ä¾¡
  assessImpact(problem) {
    return {
      users: this.estimateAffectedUsers(problem),
      systems: this.identifyAffectedSystems(problem),
      business: this.assessBusinessImpact(problem)
    };
  }

  // å¿…è¦ãªã‚¹ã‚­ãƒ«ã®ç‰¹å®š
  identifyRequiredSkills(causes) {
    const skillMap = {
      'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯': ['Network', 'TCP/IP', 'HTTP'],
      'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹': ['SQL', 'Database Design', 'Indexing'],
      'ã‚³ãƒ¼ãƒ‰': ['Programming', 'Debugging', 'Testing'],
      'è¨­å®š': ['Configuration Management', 'YAML/JSON', 'Environment Variables'],
      'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹': ['Performance Tuning', 'Profiling', 'Optimization']
    };

    const requiredSkills = new Set();
    causes.forEach(cause => {
      for (const [category, skills] of Object.entries(skillMap)) {
        if (cause.toLowerCase().includes(category.toLowerCase())) {
          skills.forEach(skill => requiredSkills.add(skill));
        }
      }
    });

    return Array.from(requiredSkills);
  }

  // è¤‡é›‘æ€§ã®è¦‹ç©ã‚‚ã‚Š
  estimateComplexity(analysis) {
    const complexityFactors = {
      causes: analysis.possibleCauses.length,
      systems: analysis.impact.systems.length,
      skills: analysis.requiredSkills.length
    };

    const score = complexityFactors.causes * 2 + complexityFactors.systems * 3 + complexityFactors.skills;

    if (score <= 5) return 'low';
    if (score <= 15) return 'medium';
    return 'high';
  }

  // é¡ä¼¼å•é¡Œã®æ¤œç´¢
  findSimilarProblems(problem) {
    return this.problemHistory
      .filter(p => p.id !== problem.id && p.category === problem.category)
      .slice(0, 3)
      .map(p => ({
        id: p.id,
        title: p.title,
        similarity: this.calculateSimilarity(problem, p)
      }))
      .filter(p => p.similarity > 0.5);
  }

  // é¡ä¼¼åº¦ã®è¨ˆç®—
  calculateSimilarity(problem1, problem2) {
    // ç°¡æ˜“çš„ãªé¡ä¼¼åº¦è¨ˆç®—ï¼ˆå®Ÿéš›ã«ã¯ã‚ˆã‚Šé«˜åº¦ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ï¼‰
    const titleSimilarity = this.calculateStringSimilarity(problem1.title, problem2.title);
    const descSimilarity = this.calculateStringSimilarity(problem1.description, problem2.description);

    return (titleSimilarity * 0.6 + descSimilarity * 0.4);
  }

  // æ–‡å­—åˆ—é¡ä¼¼åº¦ã®è¨ˆç®—
  calculateStringSimilarity(str1, str2) {
    const words1 = str1.toLowerCase().split(/\s+/);
    const words2 = str2.toLowerCase().split(/\s+/);

    const intersection = words1.filter(word => words2.includes(word));
    const union = [...new Set([...words1, ...words2])];

    return intersection.length / union.length;
  }

  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®æ›´æ–°
  updateMetrics(problem) {
    this.metrics.totalProblems++;
    this.metrics.commonProblems.set(
      problem.category,
      (this.metrics.commonProblems.get(problem.category) || 0) + 1
    );
  }

  // 5 Whysã®è³ªå•ï¼ˆãƒ¢ãƒƒã‚¯å®Ÿè£…ï¼‰
  async askWhy(question, problem) {
    // å®Ÿéš›ã«ã¯Claude Codeã‚„ä»–ã®åˆ†æãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨
    const whyResponses = {
      'ãªãœã€Œã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã™ã‚‹ã€ãŒç™ºç”Ÿã—ãŸã®ã‹ï¼Ÿ': 'ãƒ¡ãƒ¢ãƒªä¸è¶³ãŒç™ºç”Ÿã—ãŸãŸã‚',
      'ãªãœã€Œãƒ¡ãƒ¢ãƒªä¸è¶³ãŒç™ºç”Ÿã—ãŸã€ãŒç™ºç”Ÿã—ãŸã®ã‹ï¼Ÿ': 'ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒã‚ã£ãŸãŸã‚',
      'ãªãœã€Œãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒã‚ã£ãŸã€ãŒç™ºç”Ÿã—ãŸã®ã‹ï¼Ÿ': 'ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾å¿˜ã‚ŒãŒã‚ã£ãŸãŸã‚',
      'ãªãœã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾å¿˜ã‚ŒãŒã‚ã£ãŸã€ãŒç™ºç”Ÿã—ãŸã®ã‹ï¼Ÿ': 'é©åˆ‡ãªãƒ¡ãƒ¢ãƒªç®¡ç†ãƒ«ãƒ¼ãƒ«ãŒãªã‹ã£ãŸãŸã‚',
      'ãªãœã€Œé©åˆ‡ãªãƒ¡ãƒ¢ãƒªç®¡ç†ãƒ«ãƒ¼ãƒ«ãŒãªã‹ã£ãŸã€ãŒç™ºç”Ÿã—ãŸã®ã‹ï¼Ÿ': 'ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„ã¨ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ãŒä¸ååˆ†ã ã£ãŸãŸã‚'
    };

    return whyResponses[question] || 'åŸå› ã‚’ç‰¹å®šã§ãã¾ã›ã‚“ã§ã—ãŸ';
  }

  // é–¢é€£åŸå› ã®ç‰¹å®š
  async identifyRelevantCauses(problem, causes) {
    // å®Ÿéš›ã«ã¯å•é¡Œã®å†…å®¹ã«åŸºã¥ã„ã¦é–¢é€£æ€§ã‚’è©•ä¾¡
    return causes.slice(0, 2); // æœ€åˆã®2ã¤ã‚’é–¢é€£åŸå› ã¨ã—ã¦è¿”ã™
  }

  // è§£æ±ºç­–ã®è©•ä¾¡ãƒ¡ã‚½ãƒƒãƒ‰
  evaluateEffectiveness(solution) {
    return solution.effectiveness || 0.7;
  }

  evaluateFeasibility(solution) {
    const complexityMap = { low: 0.9, medium: 0.7, high: 0.5 };
    return complexityMap[solution.complexity] || 0.7;
  }

  evaluateRisk(solution) {
    const riskMap = { low: 0.9, medium: 0.7, high: 0.5 };
    return riskMap[solution.risk] || 0.7;
  }

  evaluateCost(solution) {
    const timeframeMap = { '1-2æ—¥': 0.9, '2-3æ—¥': 0.7, '1é€±é–“ä»¥ä¸Š': 0.5 };
    return timeframeMap[solution.timeframe] || 0.7;
  }

  // å½±éŸ¿ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°ã®è¦‹ç©ã‚‚ã‚Š
  estimateAffectedUsers(problem) {
    // å®Ÿéš›ã®ç’°å¢ƒã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°ã‚’æ¨å®š
    return Math.floor(Math.random() * 10000) + 100;
  }

  // å½±éŸ¿ã‚·ã‚¹ãƒ†ãƒ ã®ç‰¹å®š
  identifyAffectedSystems(problem) {
    // å®Ÿéš›ã®ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆã‹ã‚‰å½±éŸ¿ã‚’å—ã‘ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’ç‰¹å®š
    return ['auth-service', 'api-gateway', 'database'];
  }

  // ãƒ“ã‚¸ãƒã‚¹å½±éŸ¿ã®è©•ä¾¡
  assessBusinessImpact(problem) {
    const severityMap = {
      low: 'minimal',
      medium: 'moderate',
      high: 'significant',
      critical: 'critical'
    };
    return severityMap[problem.severity] || 'minimal';
  }

  // äºˆé˜²ç­–ã®ç”Ÿæˆãƒ¡ã‚½ãƒƒãƒ‰
  async generateCodePreventiveMeasures(problem) {
    return [
      {
        type: 'code_review',
        description: 'é–¢é€£ã™ã‚‹ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã®è¿½åŠ ',
        implementation: 'ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹ã®æ›´æ–°'
      }
    ];
  }

  async generateProcessPreventiveMeasures(problem) {
    return [
      {
        type: 'process',
        description: 'ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ—ãƒ­ã‚»ã‚¹ã®æ”¹å–„',
        implementation: 'ãƒ‡ãƒ—ãƒ­ã‚¤ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã®è¿½åŠ '
      }
    ];
  }

  async setupMonitoring(problem) {
    return [
      {
        type: 'monitoring',
        description: 'é–¢é€£ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ç›£è¦–è¨­å®š',
        implementation: 'ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã¨ã‚¢ãƒ©ãƒ¼ãƒˆã®è¨­å®š'
      }
    ];
  }

  async createPreventiveDocumentation(problem) {
    return [
      {
        type: 'documentation',
        description: 'ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰ã®ä½œæˆ',
        implementation: 'ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã¸ã®è¿½åŠ '
      }
    ];
  }

  // å®Ÿè£…é–¢é€£ã®ãƒ¡ã‚½ãƒƒãƒ‰
  async createImplementationPlan(solution, implementation) {
    return {
      steps: [
        'ç¾åœ¨ã®çŠ¶æ…‹ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—',
        'å¤‰æ›´ã®é©ç”¨',
        'ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ',
        'ãƒ‡ãƒ—ãƒ­ã‚¤'
      ],
      rollbackPlan: 'å¤‰æ›´å‰ã®çŠ¶æ…‹ã«ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯',
      testPlan: 'é–¢é€£ã™ã‚‹æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ'
    };
  }

  async implementSafetyMeasures(problem, solution) {
    return [
      'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—',
      'ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆä½œæˆ'
    ];
  }

  async applySolution(solution, plan) {
    // å®Ÿéš›ã®å®Ÿè£…ãƒ­ã‚¸ãƒƒã‚¯
    return {
      success: true,
      changes: ['è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æ›´æ–°', 'ã‚³ãƒ¼ãƒ‰ã®ä¿®æ­£'],
      timestamp: new Date()
    };
  }

  async verifySolution(problem, solution, implementation) {
    // å®Ÿéš›ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯
    return {
      success: true,
      tests: ['æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ', 'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ'],
      results: 'ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹'
    };
  }

  async updateDocumentation(problem, solution, implementation) {
    // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯
    console.log('ğŸ“š ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°ã—ã¾ã—ãŸ');
  }

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
}

module.exports = { TroubleshootingFramework };
```

:::

## ä¸€èˆ¬çš„ãªå•é¡Œã¨è§£æ±ºç­–

### ã‚ˆãã‚ã‚‹é–‹ç™ºå•é¡Œã®ãƒ‘ã‚¿ãƒ¼ãƒ³

:::step

1. å•é¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ä½œæˆ

`src/problem-patterns.js`ã‚’ä½œæˆã—ã€ä¸€èˆ¬çš„ãªé–‹ç™ºå•é¡Œã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨è§£æ±ºç­–ã‚’å®šç¾©ã—ã¾ã™ã€‚

_src/problem-patterns.js_

```javascript
/**
 * ä¸€èˆ¬çš„ãªé–‹ç™ºå•é¡Œã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨è§£æ±ºç­–
 */
const problemPatterns = {
  // ãƒ“ãƒ«ãƒ‰é–¢é€£ã®å•é¡Œ
  build: {
    patterns: [
      {
        name: 'ä¾å­˜é–¢ä¿‚ã®ç«¶åˆ',
        symptoms: ['npm install ãŒå¤±æ•—ã™ã‚‹', 'ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹'],
        causes: ['ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ä¸ä¸€è‡´', 'äº’æ›æ€§ã®ãªã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸'],
        solutions: [
          'package.json ã®ä¾å­˜é–¢ä¿‚ã‚’æ•´ç†',
          'npm audit ã§è„†å¼±æ€§ã‚’ãƒã‚§ãƒƒã‚¯',
          'node_modules ã¨ package-lock.json ã‚’å‰Šé™¤ã—ã¦å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«'
        ],
        prevention: [
          'ä¾å­˜é–¢ä¿‚ã®å®šæœŸçš„ãªæ›´æ–°',
          'ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã®ä½¿ç”¨',
          'CI/CDã§ã®ãƒ“ãƒ«ãƒ‰ãƒ†ã‚¹ãƒˆ'
        ]
      },
      {
        name: 'ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼',
        symptoms: ['TypeScript ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼', 'æ§‹æ–‡ã‚¨ãƒ©ãƒ¼'],
        causes: ['å‹ã®ä¸ä¸€è‡´', 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®å•é¡Œ', 'è¨­å®šã®èª¤ã‚Š'],
        solutions: [
          'ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ³¨æ„æ·±ãèª­ã‚€',
          'TypeScript ã®è¨­å®šã‚’ç¢ºèª',
          'å‹å®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«'
        ],
        prevention: [
          'ã‚¨ãƒ‡ã‚£ã‚¿ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒã‚§ãƒƒã‚¯',
          'äº‹å‰ã®å‹ãƒã‚§ãƒƒã‚¯',
          'ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ã®å‹ãƒã‚§ãƒƒã‚¯'
        ]
      }
    ]
  },

  // å®Ÿè¡Œæ™‚ã®å•é¡Œ
  runtime: {
    patterns: [
      {
        name: 'ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯',
        symptoms: ['ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®é…å»¶', 'ã‚¯ãƒ©ãƒƒã‚·ãƒ¥', 'ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®å¢—åŠ '],
        causes: ['ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾å¿˜ã‚Œ', 'ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è§£é™¤å¿˜ã‚Œ', 'ç„¡é™ãƒ«ãƒ¼ãƒ—'],
        solutions: [
          'ãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ãƒ„ãƒ¼ãƒ«ã®ä½¿ç”¨',
          'ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®é©åˆ‡ãªç®¡ç†',
          'ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ç†è§£'
        ],
        prevention: [
          'ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®ç›£è¦–',
          'ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ã®ãƒ¡ãƒ¢ãƒªç®¡ç†ãƒã‚§ãƒƒã‚¯',
          'è² è·ãƒ†ã‚¹ãƒˆã®å®Ÿæ–½'
        ]
      },
      {
        name: 'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œ',
        symptoms: ['ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒé…ã„', 'CPU ä½¿ç”¨ç‡ãŒé«˜ã„', 'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªãŒé…ã„'],
        causes: ['éåŠ¹ç‡ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ', 'ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä¸è¶³', 'N+1 ã‚¯ã‚¨ãƒªå•é¡Œ'],
        solutions: [
          'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°',
          'ã‚¯ã‚¨ãƒªã®æœ€é©åŒ–',
          'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®å°å…¥',
          'ã‚³ãƒ¼ãƒ‰ã®æœ€é©åŒ–'
        ],
        prevention: [
          'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã®ç¶™ç¶šçš„å®Ÿæ–½',
          'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¨­è¨ˆ',
          'ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®è¤‡é›‘æ€§ã®è€ƒæ…®'
        ]
      }
    ]
  },

  // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é–¢é€£ã®å•é¡Œ
  network: {
    patterns: [
      {
        name: 'æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ',
        symptoms: ['API å‘¼ã³å‡ºã—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ', 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼'],
        causes: ['ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®é…å»¶', 'ã‚µãƒ¼ãƒãƒ¼ã®éè² è·', 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã®å•é¡Œ'],
        solutions: [
          'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå€¤ã®èª¿æ•´',
          'ãƒªãƒˆãƒ©ã‚¤ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã®å®Ÿè£…',
          'æ¥ç¶šãƒ—ãƒ¼ãƒ«ã®ä½¿ç”¨',
          'ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã®å®Ÿè£…'
        ],
        prevention: [
          'æ¥ç¶šã®ç›£è¦–',
          'è² è·åˆ†æ•£ã®å°å…¥',
          'ãƒ•ã‚§ã‚¤ãƒ«ã‚ªãƒ¼ãƒãƒ¼ã®è¨­å®š'
        ]
      },
      {
        name: 'CORS ã‚¨ãƒ©ãƒ¼',
        symptoms: ['ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã« CORS ã‚¨ãƒ©ãƒ¼', 'API å‘¼ã³å‡ºã—ãŒå¤±æ•—'],
        causes: ['ã‚ªãƒªã‚¸ãƒ³ã®ä¸ä¸€è‡´', 'CORS è¨­å®šã®ä¸è¶³'],
        solutions: [
          'ã‚µãƒ¼ãƒãƒ¼å´ã® CORS è¨­å®š',
          'ãƒ—ãƒ­ã‚­ã‚·ã®ä½¿ç”¨',
          'JSONP ã®ä½¿ç”¨ï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ç”¨ï¼‰'
        ],
        prevention: [
          'é–‹ç™ºç’°å¢ƒã§ã® CORS è¨­å®š',
          'API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã® CORS ãƒãƒªã‚·ãƒ¼ã®æ˜è¨˜'
        ]
      }
    ]
  },

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é–¢é€£ã®å•é¡Œ
  database: {
    patterns: [
      {
        name: 'ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯',
        symptoms: ['ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒãƒãƒ³ã‚°ã™ã‚‹', 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼'],
        causes: ['ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®é †åºã®å•é¡Œ', 'ãƒ­ãƒƒã‚¯ã®ç«¶åˆ'],
        solutions: [
          'ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®é †åºã®æœ€é©åŒ–',
          'ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®è¨­å®š',
          'ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡ºã®æœ‰åŠ¹åŒ–'
        ],
        prevention: [
          'ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®çŸ­ç¸®',
          'é©åˆ‡ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¨­è¨ˆ',
          'ã‚¯ã‚¨ãƒªã®æœ€é©åŒ–'
        ]
      },
      {
        name: 'ãƒ‡ãƒ¼ã‚¿ã®ä¸æ•´åˆ',
        symptoms: ['ãƒ‡ãƒ¼ã‚¿ã®çŸ›ç›¾', 'å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„é•å'],
        causes: ['ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸é©åˆ‡ãªä½¿ç”¨', 'åŒæ™‚å®Ÿè¡Œåˆ¶å¾¡ã®å•é¡Œ'],
        solutions: [
          'ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®é©åˆ‡ãªä½¿ç”¨',
          'æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ã¾ãŸã¯æ‚²è¦³çš„ãƒ­ãƒƒã‚¯ã®ä½¿ç”¨',
          'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆ¶ç´„ã®å¼·åŒ–'
        ],
        prevention: [
          'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆ¶ç´„ã®é©åˆ‡ãªè¨­è¨ˆ',
          'ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³åˆ†é›¢ãƒ¬ãƒ™ãƒ«ã®ç†è§£',
          'æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã®å®Ÿè£…'
        ]
      }
    ]
  },

  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é–¢é€£ã®å•é¡Œ
  security: {
    patterns: [
      {
        name: 'èªè¨¼ã®å•é¡Œ',
        symptoms: ['ãƒ­ã‚°ã‚¤ãƒ³ã§ããªã„', 'ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒåˆ‡ã‚Œã‚‹', 'æ¨©é™ã‚¨ãƒ©ãƒ¼'],
        causes: ['ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™', 'è¨­å®šã®èª¤ã‚Š', 'ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®å•é¡Œ'],
        solutions: [
          'ãƒˆãƒ¼ã‚¯ãƒ³æœ‰åŠ¹æœŸé™ã®èª¿æ•´',
          'èªè¨¼è¨­å®šã®ç¢ºèª',
          'ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®æ”¹å–„'
        ],
        prevention: [
          'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã®å®Ÿæ–½',
          'èªè¨¼ãƒ•ãƒ­ãƒ¼ã®å®šæœŸçš„ãªãƒ¬ãƒ“ãƒ¥ãƒ¼',
          'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã®é©ç”¨'
        ]
      },
      {
        name: 'SQL ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³',
        symptoms: ['ãƒ‡ãƒ¼ã‚¿ã®ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹', 'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼'],
        causes: ['å‹•çš„ SQL ã®ä¸é©åˆ‡ãªä½¿ç”¨', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®æ¤œè¨¼ä¸è¶³'],
        solutions: [
          'ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã®ä½¿ç”¨',
          'ORM ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä½¿ç”¨',
          'å…¥åŠ›æ¤œè¨¼ã®å¼·åŒ–'
        ],
        prevention: [
          'é™çš„ã‚³ãƒ¼ãƒ‰åˆ†æ',
          'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°',
          'ä¾µå…¥ãƒ†ã‚¹ãƒˆã®å®Ÿæ–½'
        ]
      }
    ]
  }
};

class ProblemPatternMatcher {
  constructor() {
    this.patterns = problemPatterns;
  }

  // å•é¡Œã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
  matchProblem(symptoms, category = null) {
    const matches = [];

    const categories = category ? [category] : Object.keys(this.patterns);

    for (const cat of categories) {
      if (this.patterns[cat]) {
        for (const pattern of this.patterns[cat].patterns) {
          const matchScore = this.calculateMatchScore(symptoms, pattern.symptoms);
          if (matchScore > 0.3) { // 30% ä»¥ä¸Šã®ä¸€è‡´ã§ãƒãƒƒãƒã¨è¦‹ãªã™
            matches.push({
              ...pattern,
              category: cat,
              matchScore
            });
          }
        }
      }
    }

    // ãƒãƒƒãƒã‚¹ã‚³ã‚¢ã§ã‚½ãƒ¼ãƒˆ
    return matches.sort((a, b) => b.matchScore - a.matchScore);
  }

  // è§£æ±ºç­–ã®æ¨å¥¨
  recommendSolutions(symptoms, category = null) {
    const matches = this.matchProblem(symptoms, category);
    const recommendations = [];

    matches.forEach(match => {
      recommendations.push({
        problem: match.name,
        category: match.category,
        confidence: match.matchScore,
        causes: match.causes,
        solutions: match.solutions,
        prevention: match.prevention
      });
    });

    return recommendations;
  }

  // ãƒãƒƒãƒã‚¹ã‚³ã‚¢ã®è¨ˆç®—
  calculateMatchScore(symptoms, patternSymptoms) {
    if (!symptoms || !patternSymptoms) return 0;

    const symptomSet = new Set(symptoms.map(s => s.toLowerCase()));
    const patternSet = new Set(patternSymptoms.map(s => s.toLowerCase()));

    const intersection = new Set([...symptomSet].filter(x => patternSet.has(x)));
    const union = new Set([...symptomSet, ...patternSet]);

    return intersection.size / union.size;
  }

  // äºˆé˜²ç­–ã®å–å¾—
  getPreventionMeasures(category) {
    const measures = [];

    if (this.patterns[category]) {
      this.patterns[category].patterns.forEach(pattern => {
        measures.push(...pattern.prevention);
      });
    }

    return [...new Set(measures)]; // é‡è¤‡ã‚’é™¤å»
  }

  // å•é¡Œã®çµ±è¨ˆæƒ…å ±
  getProblemStatistics() {
    const stats = {};

    Object.keys(this.patterns).forEach(category => {
      stats[category] = {
        patternCount: this.patterns[category].patterns.length,
        commonSymptoms: this.getCommonSymptoms(category),
        topCauses: this.getTopCauses(category)
      };
    });

    return stats;
  }

  // ã‚«ãƒ†ã‚´ãƒªå†…ã®ä¸€èˆ¬çš„ãªç—‡çŠ¶
  getCommonSymptoms(category) {
    const symptomCount = {};

    if (this.patterns[category]) {
      this.patterns[category].patterns.forEach(pattern => {
        pattern.symptoms.forEach(symptom => {
          symptomCount[symptom] = (symptomCount[symptom] || 0) + 1;
        });
      });
    }

    return Object.entries(symptomCount)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([symptom, count]) => ({ symptom, count }));
  }

  // ã‚«ãƒ†ã‚´ãƒªå†…ã®ä¸»è¦ãªåŸå› 
  getTopCauses(category) {
    const causeCount = {};

    if (this.patterns[category]) {
      this.patterns[category].patterns.forEach(pattern => {
        pattern.causes.forEach(cause => {
          causeCount[cause] = (causeCount[cause] || 0) + 1;
        });
      });
    }

    return Object.entries(causeCount)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([cause, count]) => ({ cause, count }));
  }
}

module.exports = { ProblemPatternMatcher, problemPatterns };
```

2. ä½¿ç”¨ä¾‹

`examples/troubleshooting-example.js`ã‚’ä½œæˆã—ã€å®Ÿéš›ã®ä½¿ç”¨ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

_examples/troubleshooting-example.js_

```javascript
const { TroubleshootingFramework } = require('../src/troubleshooting-framework');
const { ProblemPatternMatcher } = require('../src/problem-patterns');

async function demonstrateTroubleshooting() {
  console.log('ğŸ”§ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®ãƒ‡ãƒ¢');
  console.log('=' .repeat(60));

  try {
    // 1. ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®åˆæœŸåŒ–
    console.log('\n1. ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®åˆæœŸåŒ–');
    const framework = new TroubleshootingFramework();
    const patternMatcher = new ProblemPatternMatcher();

    // 2. å•é¡Œã®å ±å‘Š
    console.log('\n2. å•é¡Œã®å ±å‘Š');
    const problem = await framework.reportProblem({
      title: 'API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒé…ã„',
      description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ API ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ ãŒå¹³å‡ 5 ç§’ä»¥ä¸Šã‹ã‹ã‚‹',
      category: 'runtime',
      severity: 'high',
      environment: {
        nodeVersion: '18.16.0',
        database: 'PostgreSQL 14',
        loadBalancer: 'nginx'
      },
      reproductions: [
        'é«˜è² è·æ™‚ã«å†ç¾',
        'ç‰¹å®šã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ç™ºç”Ÿ'
      ],
      reportedBy: 'å±±ç”°å¤ªéƒ'
    });

    console.log('ğŸ“Š å•é¡Œåˆ†æçµæœ:');
    console.log(`  ç¢ºä¿¡åº¦: ${problem.analysis.confidence}`);
    console.log(`  è¤‡é›‘æ€§: ${problem.analysis.estimatedComplexity}`);
    console.log(`  å½±éŸ¿ãƒ¦ãƒ¼ã‚¶ãƒ¼: ${problem.analysis.impact.users}äºº`);
    console.log(`  è€ƒãˆã‚‰ã‚Œã‚‹åŸå› : ${problem.analysis.possibleCauses.length}ä»¶`);

    // 3. ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
    console.log('\n3. å•é¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒãƒƒãƒãƒ³ã‚°');
    const symptoms = [
      'ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒé…ã„',
      'API å‘¼ã³å‡ºã—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ',
      'CPU ä½¿ç”¨ç‡ãŒé«˜ã„'
    ];

    const matches = patternMatcher.matchProblem(symptoms, 'runtime');
    console.log('ğŸ” ãƒãƒƒãƒã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³:');
    matches.forEach((match, index) => {
      console.log(`  ${index + 1}. ${match.name} (${(match.matchScore * 100).toFixed(1)}% ä¸€è‡´)`);
      console.log(`     ã‚«ãƒ†ã‚´ãƒª: ${match.category}`);
      console.log(`     åŸå› : ${match.causes.join(', ')}`);
    });

    // 4. æ ¹æœ¬åŸå› åˆ†æ
    console.log('\n4. æ ¹æœ¬åŸå› åˆ†æ');
    const rootCause = await framework.performRootCauseAnalysis(problem.id);
    console.log('ğŸ¯ æ ¹æœ¬åŸå› :');
    console.log(`  ä¸»è¦åŸå› : ${rootCause.primary}`);
    console.log(`  å¯„ä¸è¦å› : ${rootCause.contributingFactors.join(' â†’ ')}`);

    // 5. è§£æ±ºç­–ã®ç”Ÿæˆ
    console.log('\n5. è§£æ±ºç­–ã®ç”Ÿæˆ');
    const solutions = await framework.generateSolutions(problem.id);
    console.log('ğŸ’¡ ç”Ÿæˆã•ã‚ŒãŸè§£æ±ºç­–:');
    solutions.solutions.forEach((solution, index) => {
      console.log(`  ${index + 1}. ${solution.title}`);
      console.log(`     è¤‡é›‘ã•: ${solution.complexity}`);
      console.log(`     ãƒªã‚¹ã‚¯: ${solution.risk}`);
      console.log(`     æœŸé–“: ${solution.timeframe}`);
      console.log(`     æœ‰åŠ¹æ€§: ${(solution.effectiveness * 100).toFixed(0)}%`);
    });

    console.log(`\nğŸ¯ æ¨å¥¨è§£æ±ºç­–: ${solutions.recommendation.title}`);

    // 6. è§£æ±ºç­–ã®å®Ÿè£…ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
    console.log('\n6. è§£æ±ºç­–ã®å®Ÿè£…ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰');
    const implementation = {
      implementedBy: 'ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†è€…',
      changes: [
        'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¿½åŠ ',
        'ã‚¯ã‚¨ãƒªã®æœ€é©åŒ–',
        'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®å°å…¥'
      ]
    };

    const result = await framework.implementSolution(
      problem.id,
      solutions.recommendation.id,
      implementation
    );

    console.log('âœ… å®Ÿè£…çµæœ:');
    console.log(`  æˆåŠŸ: ${result.success}`);
    console.log(`  æ¤œè¨¼: ${result.verification.tests.join(', ')}`);

    // 7. äºˆé˜²ç­–ã®å®Ÿè£…
    console.log('\n7. äºˆé˜²ç­–ã®å®Ÿè£…');
    const preventiveMeasures = await framework.implementPreventiveMeasures(problem.id);
    console.log('ğŸ›¡ï¸  å®Ÿè£…ã•ã‚ŒãŸäºˆé˜²ç­–:');
    preventiveMeasures.forEach((measure, index) => {
      console.log(`  ${index + 1}. ${measure.type}: ${measure.description}`);
    });

    // 8. çµ±è¨ˆæƒ…å ±ã®è¡¨ç¤º
    console.log('\n8. å•é¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ã®çµ±è¨ˆ');
    const stats = patternMatcher.getProblemStatistics();
    console.log('ğŸ“Š ã‚«ãƒ†ã‚´ãƒªåˆ¥çµ±è¨ˆ:');
    Object.entries(stats).forEach(([category, stat]) => {
      console.log(`  ${category}:`);
      console.log(`    ãƒ‘ã‚¿ãƒ¼ãƒ³æ•°: ${stat.patternCount}`);
      console.log(`    ä¸€èˆ¬çš„ç—‡çŠ¶: ${stat.commonSymptoms[0]?.symptom || 'ãªã—'} (${stat.commonSymptoms[0]?.count || 0}ä»¶)`);
    });

    console.log('\nğŸ‰ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ‡ãƒ¢ãŒå®Œäº†ã—ã¾ã—ãŸï¼');

    // 9. å•é¡Œè§£æ±ºã®ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    console.log('\n9. å•é¡Œè§£æ±ºãƒ¬ãƒãƒ¼ãƒˆ');
    const report = generateTroubleshootingReport(problem, solutions, result);
    console.log(report);

  } catch (error) {
    console.error('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error.message);
  }
}

function generateTroubleshootingReport(problem, solutions, result) {
  return `
ğŸ“‹ å•é¡Œè§£æ±ºãƒ¬ãƒãƒ¼ãƒˆ
==================

å•é¡Œ: ${problem.title}
ã‚«ãƒ†ã‚´ãƒª: ${problem.category}
æ·±åˆ»åº¦: ${problem.severity}
å ±å‘Šè€…: ${problem.reportedBy}

ğŸ¯ æ ¹æœ¬åŸå› : ${problem.rootCause?.primary || 'åˆ†æä¸­'}

ğŸ’¡ å®Ÿæ–½ã—ãŸè§£æ±ºç­–:
${solutions.recommendation.title}
- è¤‡é›‘ã•: ${solutions.recommendation.complexity}
- æœŸé–“: ${solutions.recommendation.timeframe}
- æœ‰åŠ¹æ€§: ${(solutions.recommendation.effectiveness * 100).toFixed(0)}%

âœ… å®Ÿè£…çµæœ:
${result.implementation.changes.map(change => `- ${change}`).join('\n')}

ğŸ”§ äºˆé˜²ç­–:
${problem.preventiveMeasures?.map(measure => `- ${measure.description}`).join('\n') || 'å®Ÿè£…ä¸­'}

ğŸ“Š æ”¹å–„åŠ¹æœ:
- å•é¡Œè§£æ±ºæ™‚é–“: ${Math.floor((new Date() - problem.reportedAt) / 60000)}åˆ†
- äºˆé˜²çš„æªç½®: ${problem.preventiveMeasures?.length || 0}ä»¶
`;
}

// ãƒ‡ãƒ¢ã®å®Ÿè¡Œ
demonstrateTroubleshooting().catch(console.error);
```

:::

## äºˆé˜²çš„ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

å•é¡ŒãŒç™ºç”Ÿã™ã‚‹å‰ã«å¯¾ç­–ã‚’è¬›ã˜ã‚‹ã“ã¨ã§ã€å¤šãã®å•é¡Œã‚’æœªç„¶ã«é˜²ãã“ã¨ãŒã§ãã¾ã™ã€‚

### ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¨æ—©æœŸæ¤œçŸ¥

:::step

1. ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

`src/monitoring-system.js`ã‚’ä½œæˆã—ã€äºˆé˜²çš„ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

_src/monitoring-system.js_

```javascript
/**
 * äºˆé˜²çš„ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
 * å•é¡Œã®æ—©æœŸæ¤œçŸ¥ã¨è­¦å‘Š
 */
class MonitoringSystem {
  constructor() {
    this.metrics = new Map();
    this.alerts = [];
    this.thresholds = new Map();
    this.trends = new Map();
  }

  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®åé›†
  collectMetric(metricName, value, timestamp = new Date()) {
    if (!this.metrics.has(metricName)) {
      this.metrics.set(metricName, []);
    }

    const metricData = {
      value,
      timestamp,
      quality: this.assessDataQuality(value)
    };

    this.metrics.get(metricName).push(metricData);

    // é–¾å€¤ã®ãƒã‚§ãƒƒã‚¯
    this.checkThresholds(metricName, value);

    // ãƒˆãƒ¬ãƒ³ãƒ‰ã®åˆ†æ
    this.analyzeTrends(metricName);

    // ç•°å¸¸æ¤œçŸ¥
    this.detectAnomalies(metricName, value);

    console.log(`ğŸ“Š ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†: ${metricName} = ${value}`);
  }

  // é–¾å€¤ã®è¨­å®š
  setThreshold(metricName, warning, critical) {
    this.thresholds.set(metricName, { warning, critical });
    console.log(`âš ï¸  é–¾å€¤è¨­å®š: ${metricName} (è­¦å‘Š: ${warning}, å±é™º: ${critical})`);
  }

  // äºˆæ¸¬çš„åˆ†æ
  async performPredictiveAnalysis(metricName) {
    const metricData = this.metrics.get(metricName);
    if (!metricData || metricData.length < 10) {
      return null;
    }

    console.log(`ğŸ”® ${metricName} ã®äºˆæ¸¬åˆ†æã‚’å®Ÿè¡Œã—ã¾ã™...`);

    // ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æ
    const trend = this.calculateTrend(metricData);

    // å­£ç¯€æ€§ã®æ¤œå‡º
    const seasonality = this.detectSeasonality(metricData);

    // ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
    const anomalies = this.detectAnomalyPatterns(metricData);

    // äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«ã®é©ç”¨
    const prediction = await this.generatePrediction(metricData, trend, seasonality);

    const analysis = {
      metricName,
      currentTrend: trend,
      seasonality,
      anomalies,
      prediction,
      confidence: this.calculatePredictionConfidence(metricData, prediction),
      recommendations: await this.generateRecommendations(metricName, prediction)
    };

    console.log('ğŸ“ˆ äºˆæ¸¬åˆ†æçµæœ:');
    console.log(`  ç¾åœ¨ã®ãƒˆãƒ¬ãƒ³ãƒ‰: ${trend.direction} (${trend.strength}%)`);
    console.log(`  äºˆæ¸¬å€¤: ${prediction.value} (${prediction.timeframe})`);
    console.log(`  ç¢ºä¿¡åº¦: ${(analysis.confidence * 100).toFixed(1)}%`);

    return analysis;
  }

  // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ©ãƒ¼ãƒˆ
  generateRealtimeAlerts() {
    const currentAlerts = [];
    const now = new Date();

    // å„ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
    for (const [metricName, data] of this.metrics) {
      if (data.length === 0) continue;

      const latestValue = data[data.length - 1].value;
      const threshold = this.thresholds.get(metricName);

      if (threshold) {
        if (latestValue >= threshold.critical) {
          currentAlerts.push({
            level: 'critical',
            metric: metricName,
            value: latestValue,
            threshold: threshold.critical,
            message: `${metricName} ãŒå±é™ºãƒ¬ãƒ™ãƒ«ã«é”ã—ã¾ã—ãŸ (${latestValue} >= ${threshold.critical})`,
            timestamp: now
          });
        } else if (latestValue >= threshold.warning) {
          currentAlerts.push({
            level: 'warning',
            metric: metricName,
            value: latestValue,
            threshold: threshold.warning,
            message: `${metricName} ãŒè­¦å‘Šãƒ¬ãƒ™ãƒ«ã«é”ã—ã¾ã—ãŸ (${latestValue} >= ${threshold.warning})`,
            timestamp: now
          });
        }
      }
    }

    this.alerts.push(...currentAlerts);

    if (currentAlerts.length > 0) {
      console.log(`ğŸš¨ ${currentAlerts.length}ä»¶ã®ã‚¢ãƒ©ãƒ¼ãƒˆã‚’æ¤œå‡º`);
      currentAlerts.forEach(alert => {
        console.log(`  ${alert.level.toUpperCase()}: ${alert.message}`);
      });
    }

    return currentAlerts;
  }

  // ãƒ‡ãƒ¼ã‚¿å“è³ªã®è©•ä¾¡
  assessDataQuality(value) {
    if (value === null || value === undefined) return 'missing';
    if (typeof value !== 'number') return 'invalid_type';
    if (!isFinite(value)) return 'infinite';
    return 'good';
  }

  // é–¾å€¤ã®ãƒã‚§ãƒƒã‚¯
  checkThresholds(metricName, value) {
    const threshold = this.thresholds.get(metricName);
    if (!threshold) return;

    const dataQuality = this.assessDataQuality(value);
    if (dataQuality !== 'good') {
      console.warn(`âš ï¸  ${metricName} ã®ãƒ‡ãƒ¼ã‚¿å“è³ªãŒ ${dataQuality} ã§ã™`);
      return;
    }

    if (value >= threshold.critical) {
      this.createAlert('critical', metricName, value, threshold.critical);
    } else if (value >= threshold.warning) {
      this.createAlert('warning', metricName, value, threshold.warning);
    }
  }

  // ãƒˆãƒ¬ãƒ³ãƒ‰ã®åˆ†æ
  analyzeTrends(metricName) {
    const metricData = this.metrics.get(metricName);
    if (!metricData || metricData.length < 5) return;

    const recentData = metricData.slice(-20); // æœ€è¿‘20ä»¶
    const trend = this.calculateTrend(recentData);

    this.trends.set(metricName, {
      trend,
      lastAnalyzed: new Date()
    });

    if (Math.abs(trend.strength) > 10) { // 10%ä»¥ä¸Šã®å¤‰åŒ–ã§è­¦å‘Š
      console.log(`ğŸ“ˆ ${metricName} ã«é¡•è‘—ãªãƒˆãƒ¬ãƒ³ãƒ‰ã‚’æ¤œå‡º: ${trend.direction} ${trend.strength}%`);
    }
  }

  // ãƒˆãƒ¬ãƒ³ãƒ‰ã®è¨ˆç®—
  calculateTrend(data) {
    if (data.length < 2) return { direction: 'stable', strength: 0 };

    const values = data.map(d => d.value);
    const firstHalf = values.slice(0, Math.floor(values.length / 2));
    const secondHalf = values.slice(Math.floor(values.length / 2));

    const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;

    const changePercent = ((secondAvg - firstAvg) / firstAvg) * 100;

    return {
      direction: changePercent > 0 ? 'increasing' : changePercent < 0 ? 'decreasing' : 'stable',
      strength: Math.abs(changePercent),
      changePercent
    };
  }

  // ç•°å¸¸æ¤œçŸ¥
  detectAnomalies(metricName, currentValue) {
    const metricData = this.metrics.get(metricName);
    if (!metricData || metricData.length < 10) return;

    const values = metricData.map(d => d.value);
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
    const stdDev = Math.sqrt(variance);

    // 3Ïƒãƒ«ãƒ¼ãƒ«ã§ã®ç•°å¸¸æ¤œçŸ¥
    const zScore = (currentValue - mean) / stdDev;

    if (Math.abs(zScore) > 3) {
      console.log(`ğŸš¨ ${metricName} ã§ç•°å¸¸å€¤ã‚’æ¤œå‡º: ${currentValue} (Z-score: ${zScore.toFixed(2)})`);
      this.createAlert('anomaly', metricName, currentValue, null, `ç•°å¸¸å€¤æ¤œå‡º (Z-score: ${zScore.toFixed(2)})`);
    }
  }

  // å­£ç¯€æ€§ã®æ¤œå‡º
  detectSeasonality(data) {
    // ç°¡æ˜“çš„ãªå­£ç¯€æ€§æ¤œå‡ºï¼ˆå®Ÿéš›ã«ã¯ã‚ˆã‚Šé«˜åº¦ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ï¼‰
    if (data.length < 24) return null; // æœ€ä½24ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆå¿…è¦

    const values = data.map(d => d.value);
    const seasonalPattern = this.findSeasonalPattern(values);

    return seasonalPattern;
  }

  // å­£ç¯€ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
  findSeasonalPattern(values) {
    // å‘¨æœŸçš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡ºï¼ˆå®Ÿè£…ã¯ç°¡ç•¥åŒ–ï¼‰
    const patterns = [];
    const periodLengths = [7, 24, 168]; // æ—¥æ¬¡ã€æ™‚é–“æ¬¡ã€é€±æ¬¡

    for (const period of periodLengths) {
      if (values.length >= period * 2) {
        const correlation = this.calculateAutocorrelation(values, period);
        if (correlation > 0.7) {
          patterns.push({ period, correlation });
        }
      }
    }

    return patterns.length > 0 ? patterns : null;
  }

  // è‡ªå·±ç›¸é–¢ã®è¨ˆç®—
  calculateAutocorrelation(values, lag) {
    const n = values.length - lag;
    if (n <= 0) return 0;

    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    let numerator = 0;
    let denominator = 0;

    for (let i = 0; i < n; i++) {
      numerator += (values[i] - mean) * (values[i + lag] - mean);
      denominator += Math.pow(values[i] - mean, 2);
    }

    return denominator > 0 ? numerator / denominator : 0;
  }

  // äºˆæ¸¬ã®ç”Ÿæˆ
  async generatePrediction(data, trend, seasonality) {
    // ç°¡æ˜“çš„ãªäºˆæ¸¬ï¼ˆå®Ÿéš›ã«ã¯æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ï¼‰
    const lastValue = data[data.length - 1].value;
    const trendFactor = trend.changePercent / 100;

    let predictedValue = lastValue * (1 + trendFactor);

    // å­£ç¯€æ€§ã®èª¿æ•´
    if (seasonality) {
      const seasonalFactor = this.calculateSeasonalFactor(seasonality);
      predictedValue *= seasonalFactor;
    }

    return {
      value: Math.round(predictedValue * 100) / 100,
      timeframe: '24æ™‚é–“',
      confidence: this.calculatePredictionConfidence(data, { value: predictedValue })
    };
  }

  // å­£ç¯€æ€§å› å­ã®è¨ˆç®—
  calculateSeasonalFactor(seasonality) {
    // å­£ç¯€æ€§ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ã„ãŸèª¿æ•´å› å­ã‚’è¨ˆç®—
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã‚ˆã‚Šè¤‡é›‘ãªè¨ˆç®—ã‚’è¡Œã†
    return 1.0; // ç°¡ç•¥åŒ–ã®ãŸã‚1.0ã‚’è¿”ã™
  }

  // äºˆæ¸¬ç¢ºä¿¡åº¦ã®è¨ˆç®—
  calculatePredictionConfidence(data, prediction) {
    // ãƒ‡ãƒ¼ã‚¿ã®å“è³ªã€ãƒˆãƒ¬ãƒ³ãƒ‰ã®å®‰å®šæ€§ã€å±¥æ­´ã®é•·ã•ã«åŸºã¥ã„ã¦ç¢ºä¿¡åº¦ã‚’è¨ˆç®—
    const dataQuality = data.filter(d => d.quality === 'good').length / data.length;
    const trendStability = Math.abs(this.calculateTrend(data).changePercent) < 20 ? 1 : 0.8;
    const historyLength = Math.min(data.length / 100, 1); // 100ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã§æœ€å¤§1.0

    return (dataQuality * 0.4 + trendStability * 0.3 + historyLength * 0.3);
  }

  // æ¨å¥¨äº‹é …ã®ç”Ÿæˆ
  async generateRecommendations(metricName, prediction) {
    const threshold = this.thresholds.get(metricName);
    const recommendations = [];

    if (threshold && prediction.value >= threshold.warning) {
      recommendations.push({
        type: 'preventive',
        message: `${metricName} ãŒè­¦å‘Šé–¾å€¤ã«è¿‘ã¥ã„ã¦ã„ã¾ã™ã€‚äºˆé˜²çš„æªç½®ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚`,
        actions: [
          'ãƒªã‚½ãƒ¼ã‚¹ã®è¿½åŠ å‰²ã‚Šå½“ã¦',
          'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°',
          'è² è·åˆ†æ•£ã®è¦‹ç›´ã—'
        ]
      });
    }

    const trend = this.trends.get(metricName)?.trend;
    if (trend && trend.direction === 'increasing' && trend.strength > 5) {
      recommendations.push({
        type: 'optimization',
        message: `${metricName} ãŒå¢—åŠ å‚¾å‘ã«ã‚ã‚Šã¾ã™ã€‚æœ€é©åŒ–ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚`,
        actions: [
          'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®å°å…¥',
          'ã‚¯ã‚¨ãƒªã®æœ€é©åŒ–',
          'ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®è¦‹ç›´ã—'
        ]
      });
    }

    return recommendations;
  }

  // ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
  detectAnomalyPatterns(metricData) {
    // æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã«ãŠã‘ã‚‹ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
    const anomalies = [];
    const values = metricData.map(d => d.value);

    // çªç™ºçš„ãªå¤‰åŒ–ã®æ¤œå‡º
    for (let i = 1; i < values.length; i++) {
      const change = Math.abs(values[i] - values[i - 1]);
      const avgChange = values.reduce((sum, val, idx) => {
        if (idx === 0) return 0;
        return sum + Math.abs(val - values[idx - 1]);
      }, 0) / (values.length - 1);

      if (change > avgChange * 3) {
        anomalies.push({
          type: 'sudden_change',
          index: i,
          value: values[i],
          change: change
        });
      }
    }

    return anomalies;
  }

  // ã‚¢ãƒ©ãƒ¼ãƒˆã®ä½œæˆ
  createAlert(level, metric, value, threshold, customMessage = null) {
    const alert = {
      id: this.generateAlertId(),
      level,
      metric,
      value,
      threshold,
      message: customMessage || `${metric} alert: ${value} ${threshold ? `>= ${threshold}` : ''}`,
      timestamp: new Date(),
      acknowledged: false
    };

    this.alerts.push(alert);
    console.log(`ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ: ${alert.message}`);

    return alert;
  }

  // ã‚¢ãƒ©ãƒ¼ãƒˆIDã®ç”Ÿæˆ
  generateAlertId() {
    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œ
  async performHealthCheck() {
    console.log('ğŸ¥ ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™...');

    const healthStatus = {
      overall: 'healthy',
      metrics: {},
      alerts: [],
      recommendations: []
    };

    // å„ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
    for (const [metricName, data] of this.metrics) {
      if (data.length === 0) continue;

      const latest = data[data.length - 1];
      const threshold = this.thresholds.get(metricName);
      const trend = this.trends.get(metricName)?.trend;

      let status = 'healthy';
      if (threshold && latest.value >= threshold.critical) {
        status = 'critical';
      } else if (threshold && latest.value >= threshold.warning) {
        status = 'warning';
      } else if (trend && trend.strength > 15) {
        status = 'degraded';
      }

      healthStatus.metrics[metricName] = {
        status,
        value: latest.value,
        timestamp: latest.timestamp,
        trend: trend?.direction || 'stable'
      };

      if (status !== 'healthy') {
        healthStatus.overall = 'unhealthy';
      }
    }

    // æ¨å¥¨äº‹é …ã®ç”Ÿæˆ
    healthStatus.recommendations = await this.generateHealthRecommendations(healthStatus);

    // æœ€è¿‘ã®ã‚¢ãƒ©ãƒ¼ãƒˆ
    const recentAlerts = this.alerts.filter(a =>
      new Date() - a.timestamp < 24 * 60 * 60 * 1000 // 24æ™‚é–“ä»¥å†…
    );
    healthStatus.alerts = recentAlerts;

    console.log('ğŸ¥ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯çµæœ:');
    console.log(`  å…¨ä½“çŠ¶æ…‹: ${healthStatus.overall}`);
    console.log(`  ãƒã‚§ãƒƒã‚¯ã—ãŸãƒ¡ãƒˆãƒªã‚¯ã‚¹: ${Object.keys(healthStatus.metrics).length}`);
    console.log(`  ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¢ãƒ©ãƒ¼ãƒˆ: ${healthStatus.alerts.length}`);

    return healthStatus;
  }

  // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã«åŸºã¥ã„ãŸæ¨å¥¨äº‹é …ã®ç”Ÿæˆ
  async generateHealthRecommendations(healthStatus) {
    const recommendations = [];

    Object.entries(healthStatus.metrics).forEach(([metric, status]) => {
      if (status.status === 'critical') {
        recommendations.push({
          priority: 'high',
          metric,
          message: `${metric} ãŒå±é™ºçŠ¶æ…‹ã§ã™ã€‚å³æ™‚å¯¾å¿œãŒå¿…è¦ã§ã™ã€‚`,
          actions: ['åŸå› èª¿æŸ»', 'ç·Šæ€¥å¯¾ç­–ã®å®Ÿæ–½', 'ã‚¹ãƒ†ãƒ¼ã‚¯ãƒ›ãƒ«ãƒ€ãƒ¼ã¸ã®å ±å‘Š']
        });
      } else if (status.status === 'warning') {
        recommendations.push({
          priority: 'medium',
          metric,
          message: `${metric} ãŒè­¦å‘ŠçŠ¶æ…‹ã§ã™ã€‚ç›£è¦–ã‚’å¼·åŒ–ã—ã¦ãã ã•ã„ã€‚`,
          actions: ['çµŒéè¦³å¯Ÿ', 'äºˆé˜²ç­–ã®æ¤œè¨', 'ã—ãã„å€¤ã®è¦‹ç›´ã—']
        });
      } else if (status.status === 'degraded') {
        recommendations.push({
          priority: 'low',
          metric,
          message: `${metric} ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒä½ä¸‹ã—ã¦ã„ã¾ã™ã€‚`,
          actions: ['ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æ', 'æœ€é©åŒ–ã®æ¤œè¨', 'ãƒªã‚½ãƒ¼ã‚¹è¨ˆç”»']
        });
      }
    });

    return recommendations;
  }

  // ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
  generateReport(timeRange = '24h') {
    const report = {
      generatedAt: new Date(),
      timeRange,
      summary: {
        totalMetrics: this.metrics.size,
        totalAlerts: this.alerts.length,
        activeThresholds: this.thresholds.size
      },
      metrics: {},
      alerts: this.alerts.slice(-10), // æœ€è¿‘10ä»¶
      health: {}
    };

    // å„ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ã‚µãƒãƒªãƒ¼
    for (const [metricName, data] of this.metrics) {
      if (data.length === 0) continue;

      const values = data.map(d => d.value);
      const latest = data[data.length - 1];

      report.metrics[metricName] = {
        currentValue: latest.value,
        min: Math.min(...values),
        max: Math.max(...values),
        average: values.reduce((sum, val) => sum + val, 0) / values.length,
        trend: this.trends.get(metricName)?.trend || { direction: 'stable', strength: 0 },
        dataPoints: data.length,
        lastUpdate: latest.timestamp
      };
    }

    return report;
  }
}

module.exports = { MonitoringSystem };
```

2. ä½¿ç”¨ä¾‹

`examples/monitoring-example.js`ã‚’ä½œæˆã—ã¾ã™ã€‚

_examples/monitoring-example.js_

```javascript
const { MonitoringSystem } = require('../src/monitoring-system');

async function demonstrateMonitoring() {
  console.log('ğŸ“Š äºˆé˜²çš„ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã®ãƒ‡ãƒ¢');
  console.log('=' .repeat(60));

  try {
    // 1. ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
    console.log('\n1. ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–');
    const monitoring = new MonitoringSystem();

    // 2. é–¾å€¤ã®è¨­å®š
    console.log('\n2. ç›£è¦–é–¾å€¤ã®è¨­å®š');
    monitoring.setThreshold('cpu_usage', 70, 90);
    monitoring.setThreshold('memory_usage', 80, 95);
    monitoring.setThreshold('response_time', 1000, 3000);
    monitoring.setThreshold('error_rate', 1, 5);

    // 3. ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    console.log('\n3. ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³');
    const metrics = ['cpu_usage', 'memory_usage', 'response_time', 'error_rate'];

    for (let i = 0; i < 50; i++) {
      for (const metric of metrics) {
        // ç¾å®Ÿçš„ãªå€¤ã®ç”Ÿæˆ
        let value;
        switch (metric) {
          case 'cpu_usage':
            value = Math.random() * 100;
            break;
          case 'memory_usage':
            value = 60 + Math.random() * 40;
            break;
          case 'response_time':
            value = Math.random() * 5000;
            break;
          case 'error_rate':
            value = Math.random() * 10;
            break;
        }

        monitoring.collectMetric(metric, value);

        // 100ãƒŸãƒªç§’å¾…æ©Ÿ
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }

    // 4. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ©ãƒ¼ãƒˆã®ç”Ÿæˆ
    console.log('\n4. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ©ãƒ¼ãƒˆã®ãƒã‚§ãƒƒã‚¯');
    const alerts = monitoring.generateRealtimeAlerts();
    console.log(`ğŸš¨ ${alerts.length}ä»¶ã®ã‚¢ãƒ©ãƒ¼ãƒˆã‚’æ¤œå‡º`);

    // 5. äºˆæ¸¬åˆ†æã®å®Ÿè¡Œ
    console.log('\n5. äºˆæ¸¬åˆ†æã®å®Ÿè¡Œ');
    for (const metric of metrics) {
      const analysis = await monitoring.performPredictiveAnalysis(metric);
      if (analysis) {
        console.log(`\nğŸ“ˆ ${metric} ã®åˆ†æçµæœ:`);
        console.log(`  äºˆæ¸¬å€¤: ${analysis.prediction.value} (${analysis.prediction.timeframe})`);
        console.log(`  ç¢ºä¿¡åº¦: ${(analysis.confidence * 100).toFixed(1)}%`);

        if (analysis.recommendations.length > 0) {
          console.log('  æ¨å¥¨äº‹é …:');
          analysis.recommendations.forEach(rec => {
            console.log(`    - ${rec.message}`);
          });
        }
      }
    }

    // 6. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œ
    console.log('\n6. ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯');
    const health = await monitoring.performHealthCheck();
    console.log(`ğŸ¥ å…¨ä½“çŠ¶æ…‹: ${health.overall}`);
    console.log(`ğŸ“Š ãƒ¡ãƒˆãƒªã‚¯ã‚¹çŠ¶æ…‹:`);
    Object.entries(health.metrics).forEach(([metric, status]) => {
      const emoji = status.status === 'healthy' ? 'âœ…' :
                   status.status === 'warning' ? 'âš ï¸' : 'ğŸš¨';
      console.log(`  ${emoji} ${metric}: ${status.value.toFixed(1)} (${status.status})`);
    });

    // 7. äºˆé˜²çš„æªç½®ã®ææ¡ˆ
    console.log('\n7. äºˆé˜²çš„æªç½®ã®ææ¡ˆ');
    if (health.recommendations.length > 0) {
      health.recommendations.forEach((rec, index) => {
        const priorityEmoji = rec.priority === 'high' ? 'ğŸ”´' :
                              rec.priority === 'medium' ? 'ğŸŸ¡' : 'ğŸŸ¢';
        console.log(`${priorityEmoji} ${index + 1}. ${rec.message}`);
        console.log(`   å¯¾ç­–: ${rec.actions.join(', ')}`);
      });
    }

    // 8. ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
    console.log('\n8. ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ¬ãƒãƒ¼ãƒˆ');
    const report = monitoring.generateReport();
    console.log('ğŸ“‹ ãƒ¬ãƒãƒ¼ãƒˆã‚µãƒãƒªãƒ¼:');
    console.log(`  ç”Ÿæˆæ™‚åˆ»: ${report.generatedAt.toLocaleString()}`);
    console.log(`  ç›£è¦–ãƒ¡ãƒˆãƒªã‚¯ã‚¹: ${report.summary.totalMetrics}`);
    console.log(`  ç·ã‚¢ãƒ©ãƒ¼ãƒˆæ•°: ${report.summary.totalAlerts}`);
    console.log(`  è¨­å®šæ¸ˆã¿é–¾å€¤: ${report.summary.activeThresholds}`);

    console.log('\nğŸ‰ äºˆé˜²çš„ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ‡ãƒ¢ãŒå®Œäº†ã—ã¾ã—ãŸï¼');

  } catch (error) {
    console.error('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error.message);
  }
}

// ãƒ‡ãƒ¢ã®å®Ÿè¡Œ
demonstrateMonitoring().catch(console.error);
```

:::

## ã¾ã¨ã‚

ã“ã®ãƒšãƒ¼ã‚¸ã§ã¯ã€Claude Codeã‚’æ´»ç”¨ã—ãŸãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®ä½“ç³»çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã«ã¤ã„ã¦å­¦ã³ã¾ã—ãŸã€‚å•é¡Œç™ºç”Ÿæ™‚ã®è¿…é€Ÿãªå¯¾å¿œã ã‘ã§ãªãã€äºˆé˜²çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ã‚·ã‚¹ãƒ†ãƒ ã®ä¿¡é ¼æ€§ã¨å®‰å®šæ€§ã‚’å¤§å¹…ã«å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

:::note è¦ç‚¹ã®ã¾ã¨ã‚

- ä½“ç³»çš„ãªå•é¡Œè§£æ±ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§åŠ¹æœçš„ãªãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚’å®Ÿç¾
- 5 Whysã‚„é­šéª¨å›³ãªã©ã®åˆ†ææ‰‹æ³•ã§æ ¹æœ¬åŸå› ã‚’ç‰¹å®š
- å•é¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§éå»ã®çµŒé¨“ã‚’æ´»ç”¨
- äºˆé˜²çš„ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã§å•é¡Œã‚’æ—©æœŸæ¤œçŸ¥ãƒ»é˜²æ­¢
- Claude Codeã‚’æ´»ç”¨ã—ãŸè‡ªå‹•åˆ†æã§è§£æ±ºåŠ¹ç‡ã‚’å‘ä¸Š
- è§£æ±ºç­–ã®å®Ÿè£…ã¨æ¤œè¨¼ã§ç¢ºå®Ÿãªå•é¡Œè§£æ±ºã‚’ç¢ºä¿

:::

## é–¢é€£è¨˜äº‹

[ãƒãƒ¼ãƒ é–‹ç™ºã®åŸºç¤](../team-development-basics/team-development-basics.md)
[ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã¨Git](../version-control/version-control.md)
[ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„](../coding-standards/coding-standards.md)
[å®Ÿè·µçš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼](../practical-workflows/practical-workflows.md)